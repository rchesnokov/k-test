{"version":3,"sources":["webpack:///scripts/main.bundle.js","webpack:///webpack/bootstrap d757b5cb211cde3cc3f4","webpack:///../~/riot/riot.js","webpack:///./scripts/app.js","webpack:///. \\.(html)","webpack:///./scripts/main.js","webpack:///./index.html","webpack:///./tags/app.tag"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_typeof","Symbol","iterator","obj","constructor","global","factory","undefined","apply","this","isBoolAttr","RE_BOOL_ATTRS","test","isFunction","T_FUNCTION","isObject","T_OBJECT","isUndefined","T_UNDEF","isString","T_STRING","isBlank","isArray","Array","isWritable","key","descriptor","getOwnPropertyDescriptor","writable","isReservedName","RE_RESERVED_NAMES","$$","selector","ctx","document","querySelectorAll","$","querySelector","createFrag","createDocumentFragment","createDOMPlaceholder","createTextNode","mkEl","createElement","setInnerHTML","container","html","innerHTML","doc","DOMParser","parseFromString","node","ownerDocument","importNode","documentElement","appendChild","toggleVisibility","dom","show","style","display","remAttr","removeAttribute","styleObjectToString","keys","reduce","acc","prop","getAttr","getAttribute","setAttr","val","xlink","XLINK_REGEX","exec","setAttributeNS","XLINK_NS","setAttribute","safeInsert","root","curr","next","insertBefore","parentNode","walkAttrs","fn","RE_HTML_ATTRS","toLowerCase","walkNodes","context","res","firstChild","nextSibling","each","list","len","length","contains","array","item","indexOf","toCamel","str","replace","_","toUpperCase","startsWith","slice","el","options","extend","src","args","arguments","handleEvent","handler","e","ptag","__","parent","currentTarget","target","srcElement","which","charCode","keyCode","preventUpdate","getImmediateCustomParentTag","isMounted","update","setEventHandler","tag","eventName","cb","bind","RE_EVENTS_PREFIX","listeners","push","RIOT_EVENTS_KEY","removeEventListener","addEventListener","updateDataIs","expr","tagName","conf","isVirtual","head","ref","unmount","impl","__TAG_IMPL","hasImpl","initChildTag","attrs","a","mount","makeReplaceVirtual","onUnmount","delName","opts","dataIs","tags","_tags","arrayishRemove","normalizeAttrName","attrName","ATTRS_PREFIX","CASE_SENSITIVE_ATTRIBUTES","updateExpression","isObj","attr","isToggle","SHOW_DIRECTIVE","HIDE_DIRECTIVE","isStyleAttr","isClassAttr","_riot_id","tmpl","JSON","stringify","bool","isRtag","wasParsedOnce","IE_VERSION","nodeValue","isAttrRemoved","hidden","updateAllExpressions","expressions","mkitem","base","create","pos","unmountRedundant","items","j","remove","splice","moveNestedTags","this$1","moveChildTag","move","nextTag","moveVirtual","insert","makeVirtual","append","_each","LOOP_DIRECTIVE","hasKeys","mustReorder","LOOP_NO_REORDER_DIRECTIVE","getTagName","placeholder","child","getTag","ifExpr","CONDITIONAL_DIRECTIVE","oldItems","isAnonymous","loopKeys","isLoop","removeChild","frag","isObject$$1","map","filter","doReorder","oldPos","isNew","mustAppend","mustCreate","Tag$1","cloneNode","index","arrayishAdd","t","parseExpressions","mustIncludeRoot","tree","children","tagImpl","type","nodeType","hasExpr","IfExpr","init","IS_DIRECTIVE","attributes","parentElement","outerHTML","parseAttributes","REF_DIRECTIVES","RefExpr","specialTags","select","trim","selectedIndex","tname","rootEls","childElementCount","replaceYield","reHasYield","reYieldSrc","text","reYieldDest","def","reYieldAll","mkdom","match","GENERIC","tblTags","Tag$2","css","onCreate","tag$1","class","mountTo","styleManager","inject","add","tag2$1","mount$1","pushTagsTo","riotTag","elem","allTags","selectTags","split","nodeList","_el","mixin$1","mix","g","mixins_id","store","globals","mixins","Error","update$1","__TAGS_CACHE","unregister$1","updateOpts","instAttrs","skipAnonymous","settings$1","skipAnonymousTags","cleanUpData","implAttrs","propsInSyncWithParent","observable$1","_tag","virts","tail","__uid","data","nextOpts","canTrigger","shouldUpdate","inheritFrom","trigger","instance","props","propsBlacklist","proto","getPrototypeOf","concat","getOwnPropertyNames","hasGetterSetter","set","isPrototypeOf","k","v","globalMixin","GLOBAL_MIXIN","mixin","one","mustKeepRoot","tagIndex","forEach","unmountAll","off","mustSync","newPos","skipDataIs","namedTag","ensureArray","dest","isArr","hasIndex","oldIndex","implClass","_innerHTML","replaceChild","sib","styleNode","cssTextProp","WIN","window","viewbox","documentMode","check","freeze","byName","remainder","needsInject","newNode","userNode","id","getElementsByTagName","styleSheet","join","cssText","brackets","UNDEF","_loopback","re","_rewrite","bp","_cache","RegExp","source","REGLOB","_create","pair","DEFAULT","_pairs","arr","UNSUPPORTED","NEED_ESCAPE","S_QBLOCKS","_brackets","reOrIdx","_regex","_reset","cachedBrackets","_setSettings","b","_settings","R_STRINGS","FINDBRACES","(","[","{","_bp","unescapeStr","isexpr","parts","start","lastIndex","ch","ix","recch","settings","riot","R_MLCOMMS","_tmpl","_logErr","err","riotData","errorHandler","console","error","_getTmpl","Function","qstr","RE_DQUOTE","_parseExpr","RE_QBMARK","asText","RE_QBLOCK","div","CH_IDEXPR","cnt","RE_CSNAME","jsb","rightContext","mm","lv","ir","RE_BREND","_wrapExpr","tb","JS_VARNAME","mvar","JS_CONTEXT","JS_NOPROPS","clearCache","String","fromCharCode","version","callbacks","defineProperties","on","event","fns","arguments$1","arglen","misc","stub","pristine","current","attrValue","rawValue","hasExp","old","customParent","tagOrDom","refs","tr","th","td","col","core","Tag","tag2","unregister","util","vdom","Tag$$1","tag$$1","tag2$$1","mount$$1","mixin$$1","update$$1","unregister$$1","observable","riot$1","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0_riot__","__WEBPACK_IMPORTED_MODULE_0_riot___default","__WEBPACK_IMPORTED_MODULE_1__tags_app_tag__","webpackContext","req","webpackContextResolve","./index.html","resolve","log"],"mappings":"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","file":"./scripts/main.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* Riot v3.4.1, @license MIT */\n(function (global, factory) {\n  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.riot = global.riot || {});\n})(this, function (exports) {\n  'use strict';\n\n  var __TAGS_CACHE = [];\n  var __TAG_IMPL = {};\n  var GLOBAL_MIXIN = '__global_mixin';\n  var ATTRS_PREFIX = 'riot-';\n  var REF_DIRECTIVES = ['ref', 'data-ref'];\n  var IS_DIRECTIVE = 'data-is';\n  var CONDITIONAL_DIRECTIVE = 'if';\n  var LOOP_DIRECTIVE = 'each';\n  var LOOP_NO_REORDER_DIRECTIVE = 'no-reorder';\n  var SHOW_DIRECTIVE = 'show';\n  var HIDE_DIRECTIVE = 'hide';\n  var RIOT_EVENTS_KEY = '__riot-events__';\n  var T_STRING = 'string';\n  var T_OBJECT = 'object';\n  var T_UNDEF = 'undefined';\n  var T_FUNCTION = 'function';\n  var XLINK_NS = 'http://www.w3.org/1999/xlink';\n  var XLINK_REGEX = /^xlink:(\\w+)/;\n  var WIN = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === T_UNDEF ? undefined : window;\n  var RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\n  var RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\n  var RE_EVENTS_PREFIX = /^on/;\n  var RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\n  var RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\n  var CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\n  var RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\n  var IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\n  /**\n   * Check Check if the passed argument is undefined\n   * @param   { String } value -\n   * @returns { Boolean } -\n   */\n  function isBoolAttr(value) {\n    return RE_BOOL_ATTRS.test(value);\n  }\n\n  /**\n   * Check if passed argument is a function\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isFunction(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === T_FUNCTION;\n  }\n\n  /**\n   * Check if passed argument is an object, exclude null\n   * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isObject(value) {\n    return value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === T_OBJECT; // typeof null is 'object'\n  }\n\n  /**\n   * Check if passed argument is undefined\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isUndefined(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === T_UNDEF;\n  }\n\n  /**\n   * Check if passed argument is a string\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isString(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === T_STRING;\n  }\n\n  /**\n   * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n   * @param { * } value -\n   * @returns { Boolean } -\n   */\n  function isBlank(value) {\n    return isUndefined(value) || value === null || value === '';\n  }\n\n  /**\n   * Check if passed argument is a kind of array\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isArray(value) {\n    return Array.isArray(value) || value instanceof Array;\n  }\n\n  /**\n   * Check whether object's property could be overridden\n   * @param   { Object }  obj - source object\n   * @param   { String }  key - object property\n   * @returns { Boolean } -\n   */\n  function isWritable(obj, key) {\n    var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n    return isUndefined(obj[key]) || descriptor && descriptor.writable;\n  }\n\n  /**\n   * Check if passed argument is a reserved name\n   * @param   { String } value -\n   * @returns { Boolean } -\n   */\n  function isReservedName(value) {\n    return RE_RESERVED_NAMES.test(value);\n  }\n\n  var check = Object.freeze({\n    isBoolAttr: isBoolAttr,\n    isFunction: isFunction,\n    isObject: isObject,\n    isUndefined: isUndefined,\n    isString: isString,\n    isBlank: isBlank,\n    isArray: isArray,\n    isWritable: isWritable,\n    isReservedName: isReservedName\n  });\n\n  /**\n   * Shorter and fast way to select multiple nodes in the DOM\n   * @param   { String } selector - DOM selector\n   * @param   { Object } ctx - DOM node where the targets of our search will is located\n   * @returns { Object } dom nodes found\n   */\n  function $$(selector, ctx) {\n    return (ctx || document).querySelectorAll(selector);\n  }\n\n  /**\n   * Shorter and fast way to select a single node in the DOM\n   * @param   { String } selector - unique dom selector\n   * @param   { Object } ctx - DOM node where the target of our search will is located\n   * @returns { Object } dom node found\n   */\n  function $(selector, ctx) {\n    return (ctx || document).querySelector(selector);\n  }\n\n  /**\n   * Create a document fragment\n   * @returns { Object } document fragment\n   */\n  function createFrag() {\n    return document.createDocumentFragment();\n  }\n\n  /**\n   * Create a document text node\n   * @returns { Object } create a text node to use as placeholder\n   */\n  function createDOMPlaceholder() {\n    return document.createTextNode('');\n  }\n\n  /**\n   * Create a generic DOM node\n   * @param   { String } name - name of the DOM node we want to create\n   * @returns { Object } DOM node just created\n   */\n  function mkEl(name) {\n    return document.createElement(name);\n  }\n\n  /**\n   * Set the inner html of any DOM node SVGs included\n   * @param { Object } container - DOM node where we'll inject new html\n   * @param { String } html - html to inject\n   */\n  /* istanbul ignore next */\n  function setInnerHTML(container, html) {\n    if (!isUndefined(container.innerHTML)) {\n      container.innerHTML = html;\n    }\n    // some browsers do not support innerHTML on the SVGs tags\n    else {\n        var doc = new DOMParser().parseFromString(html, 'application/xml');\n        var node = container.ownerDocument.importNode(doc.documentElement, true);\n        container.appendChild(node);\n      }\n  }\n\n  /**\n   * Toggle the visibility of any DOM node\n   * @param   { Object }  dom - DOM node we want to hide\n   * @param   { Boolean } show - do we want to show it?\n   */\n\n  function toggleVisibility(dom, show) {\n    dom.style.display = show ? '' : 'none';\n    dom['hidden'] = show ? false : true;\n  }\n\n  /**\n   * Remove any DOM attribute from a node\n   * @param   { Object } dom - DOM node we want to update\n   * @param   { String } name - name of the property we want to remove\n   */\n  function remAttr(dom, name) {\n    dom.removeAttribute(name);\n  }\n\n  /**\n   * Convert a style object to a string\n   * @param   { Object } style - style object we need to parse\n   * @returns { String } resulting css string\n   * @example\n   * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n   */\n  function styleObjectToString(style) {\n    return Object.keys(style).reduce(function (acc, prop) {\n      return acc + \" \" + prop + \": \" + style[prop] + \";\";\n    }, '');\n  }\n\n  /**\n   * Get the value of any DOM attribute on a node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { String } name - name of the attribute we want to get\n   * @returns { String | undefined } name of the node attribute whether it exists\n   */\n  function getAttr(dom, name) {\n    return dom.getAttribute(name);\n  }\n\n  /**\n   * Set any DOM attribute\n   * @param { Object } dom - DOM node we want to update\n   * @param { String } name - name of the property we want to set\n   * @param { String } val - value of the property we want to set\n   */\n  function setAttr(dom, name, val) {\n    var xlink = XLINK_REGEX.exec(name);\n    if (xlink && xlink[1]) {\n      dom.setAttributeNS(XLINK_NS, xlink[1], val);\n    } else {\n      dom.setAttribute(name, val);\n    }\n  }\n\n  /**\n   * Insert safely a tag to fix #1962 #1649\n   * @param   { HTMLElement } root - children container\n   * @param   { HTMLElement } curr - node to insert\n   * @param   { HTMLElement } next - node that should preceed the current node inserted\n   */\n  function safeInsert(root, curr, next) {\n    root.insertBefore(curr, next.parentNode && next);\n  }\n\n  /**\n   * Minimize risk: only zero or one _space_ between attr & value\n   * @param   { String }   html - html string we want to parse\n   * @param   { Function } fn - callback function to apply on any attribute found\n   */\n  function walkAttrs(html, fn) {\n    if (!html) {\n      return;\n    }\n    var m;\n    while (m = RE_HTML_ATTRS.exec(html)) {\n      fn(m[1].toLowerCase(), m[2] || m[3] || m[4]);\n    }\n  }\n\n  /**\n   * Walk down recursively all the children tags starting dom node\n   * @param   { Object }   dom - starting node where we will start the recursion\n   * @param   { Function } fn - callback to transform the child node just found\n   * @param   { Object }   context - fn can optionally return an object, which is passed to children\n   */\n  function walkNodes(dom, fn, context) {\n    if (dom) {\n      var res = fn(dom, context);\n      var next;\n      // stop the recursion\n      if (res === false) {\n        return;\n      }\n\n      dom = dom.firstChild;\n\n      while (dom) {\n        next = dom.nextSibling;\n        walkNodes(dom, fn, res);\n        dom = next;\n      }\n    }\n  }\n\n  var dom = Object.freeze({\n    $$: $$,\n    $: $,\n    createFrag: createFrag,\n    createDOMPlaceholder: createDOMPlaceholder,\n    mkEl: mkEl,\n    setInnerHTML: setInnerHTML,\n    toggleVisibility: toggleVisibility,\n    remAttr: remAttr,\n    styleObjectToString: styleObjectToString,\n    getAttr: getAttr,\n    setAttr: setAttr,\n    safeInsert: safeInsert,\n    walkAttrs: walkAttrs,\n    walkNodes: walkNodes\n  });\n\n  var styleNode;\n  var cssTextProp;\n  var byName = {};\n  var remainder = [];\n  var needsInject = false;\n\n  // skip the following code on the server\n  if (WIN) {\n    styleNode = function () {\n      // create a new style element with the correct type\n      var newNode = mkEl('style');\n      setAttr(newNode, 'type', 'text/css');\n\n      // replace any user node or insert the new one into the head\n      var userNode = $('style[type=riot]');\n      /* istanbul ignore next */\n      if (userNode) {\n        if (userNode.id) {\n          newNode.id = userNode.id;\n        }\n        userNode.parentNode.replaceChild(newNode, userNode);\n      } else {\n        document.getElementsByTagName('head')[0].appendChild(newNode);\n      }\n\n      return newNode;\n    }();\n    cssTextProp = styleNode.styleSheet;\n  }\n\n  /**\n   * Object that will be used to inject and manage the css of every tag instance\n   */\n  var styleManager = {\n    styleNode: styleNode,\n    /**\n     * Save a tag style to be later injected into DOM\n     * @param { String } css - css string\n     * @param { String } name - if it's passed we will map the css to a tagname\n     */\n    add: function add(css, name) {\n      if (name) {\n        byName[name] = css;\n      } else {\n        remainder.push(css);\n      }\n      needsInject = true;\n    },\n    /**\n     * Inject all previously saved tag styles into DOM\n     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n     */\n    inject: function inject() {\n      if (!WIN || !needsInject) {\n        return;\n      }\n      needsInject = false;\n      var style = Object.keys(byName).map(function (k) {\n        return byName[k];\n      }).concat(remainder).join('\\n');\n      /* istanbul ignore next */\n      if (cssTextProp) {\n        cssTextProp.cssText = style;\n      } else {\n        styleNode.innerHTML = style;\n      }\n    }\n  };\n\n  /**\n   * The riot template engine\n   * @version v3.0.3\n   */\n  /**\n   * riot.util.brackets\n   *\n   * - `brackets    ` - Returns a string or regex based on its parameter\n   * - `brackets.set` - Change the current riot brackets\n   *\n   * @module\n   */\n\n  /* global riot */\n\n  /* istanbul ignore next */\n  var brackets = function (UNDEF) {\n\n    var REGLOB = 'g',\n        R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n        R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n        S_QBLOCKS = R_STRINGS.source + '|' + /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' + /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n        UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n        NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n        FINDBRACES = {\n      '(': RegExp('([()])|' + S_QBLOCKS, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n      '{': RegExp('([{}])|' + S_QBLOCKS, REGLOB)\n    },\n        DEFAULT = '{ }';\n\n    var _pairs = ['{', '}', '{', '}', /{[^}]*}/, /\\\\([{}])/g, /\\\\({)|{/g, RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB), DEFAULT, /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/, /(^|[^\\\\]){=[\\S\\s]*?}/];\n\n    var cachedBrackets = UNDEF,\n        _regex,\n        _cache = [],\n        _settings;\n\n    function _loopback(re) {\n      return re;\n    }\n\n    function _rewrite(re, bp) {\n      if (!bp) {\n        bp = _cache;\n      }\n      return new RegExp(re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : '');\n    }\n\n    function _create(pair) {\n      if (pair === DEFAULT) {\n        return _pairs;\n      }\n\n      var arr = pair.split(' ');\n\n      if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n        throw new Error('Unsupported brackets \"' + pair + '\"');\n      }\n      arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n      arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n      arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n      arr[6] = _rewrite(_pairs[6], arr);\n      arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);\n      arr[8] = pair;\n      return arr;\n    }\n\n    function _brackets(reOrIdx) {\n      return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx];\n    }\n\n    _brackets.split = function split(str, tmpl, _bp) {\n      // istanbul ignore next: _bp is for the compiler\n      if (!_bp) {\n        _bp = _cache;\n      }\n\n      var parts = [],\n          match,\n          isexpr,\n          start,\n          pos,\n          re = _bp[6];\n\n      isexpr = start = re.lastIndex = 0;\n\n      while (match = re.exec(str)) {\n\n        pos = match.index;\n\n        if (isexpr) {\n\n          if (match[2]) {\n            re.lastIndex = skipBraces(str, match[2], re.lastIndex);\n            continue;\n          }\n          if (!match[3]) {\n            continue;\n          }\n        }\n\n        if (!match[1]) {\n          unescapeStr(str.slice(start, pos));\n          start = re.lastIndex;\n          re = _bp[6 + (isexpr ^= 1)];\n          re.lastIndex = start;\n        }\n      }\n\n      if (str && start < str.length) {\n        unescapeStr(str.slice(start));\n      }\n\n      return parts;\n\n      function unescapeStr(s) {\n        if (tmpl || isexpr) {\n          parts.push(s && s.replace(_bp[5], '$1'));\n        } else {\n          parts.push(s);\n        }\n      }\n\n      function skipBraces(s, ch, ix) {\n        var match,\n            recch = FINDBRACES[ch];\n\n        recch.lastIndex = ix;\n        ix = 1;\n        while (match = recch.exec(s)) {\n          if (match[1] && !(match[1] === ch ? ++ix : --ix)) {\n            break;\n          }\n        }\n        return ix ? s.length : recch.lastIndex;\n      }\n    };\n\n    _brackets.hasExpr = function hasExpr(str) {\n      return _cache[4].test(str);\n    };\n\n    _brackets.loopKeys = function loopKeys(expr) {\n      var m = expr.match(_cache[9]);\n\n      return m ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] } : { val: expr.trim() };\n    };\n\n    _brackets.array = function array(pair) {\n      return pair ? _create(pair) : _cache;\n    };\n\n    function _reset(pair) {\n      if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n        _cache = _create(pair);\n        _regex = pair === DEFAULT ? _loopback : _rewrite;\n        _cache[9] = _regex(_pairs[9]);\n      }\n      cachedBrackets = pair;\n    }\n\n    function _setSettings(o) {\n      var b;\n\n      o = o || {};\n      b = o.brackets;\n      Object.defineProperty(o, 'brackets', {\n        set: _reset,\n        get: function get() {\n          return cachedBrackets;\n        },\n        enumerable: true\n      });\n      _settings = o;\n      _reset(b);\n    }\n\n    Object.defineProperty(_brackets, 'settings', {\n      set: _setSettings,\n      get: function get() {\n        return _settings;\n      }\n    });\n\n    /* istanbul ignore next: in the browser riot is always in the scope */\n    _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n    _brackets.set = _reset;\n\n    _brackets.R_STRINGS = R_STRINGS;\n    _brackets.R_MLCOMMS = R_MLCOMMS;\n    _brackets.S_QBLOCKS = S_QBLOCKS;\n\n    return _brackets;\n  }();\n\n  /**\n   * @module tmpl\n   *\n   * tmpl          - Root function, returns the template value, render with data\n   * tmpl.hasExpr  - Test the existence of a expression inside a string\n   * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n   */\n\n  /* istanbul ignore next */\n  var tmpl = function () {\n\n    var _cache = {};\n\n    function _tmpl(str, data) {\n      if (!str) {\n        return str;\n      }\n\n      return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr);\n    }\n\n    _tmpl.hasExpr = brackets.hasExpr;\n\n    _tmpl.loopKeys = brackets.loopKeys;\n\n    // istanbul ignore next\n    _tmpl.clearCache = function () {\n      _cache = {};\n    };\n\n    _tmpl.errorHandler = null;\n\n    function _logErr(err, ctx) {\n\n      err.riotData = {\n        tagName: ctx && ctx.__ && ctx.__.tagName,\n        _riot_id: ctx && ctx._riot_id //eslint-disable-line camelcase\n      };\n\n      if (_tmpl.errorHandler) {\n        _tmpl.errorHandler(err);\n      } else if (typeof console !== 'undefined' && typeof console.error === 'function') {\n        if (err.riotData.tagName) {\n          console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName);\n        }\n        console.error(err);\n      }\n    }\n\n    function _create(str) {\n      var expr = _getTmpl(str);\n\n      if (expr.slice(0, 11) !== 'try{return ') {\n        expr = 'return ' + expr;\n      }\n\n      return new Function('E', expr + ';'); // eslint-disable-line no-new-func\n    }\n\n    var CH_IDEXPR = String.fromCharCode(0x2057),\n        RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n        RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n        RE_DQUOTE = /\\u2057/g,\n        RE_QBMARK = /\\u2057(\\d+)~/g;\n\n    function _getTmpl(str) {\n      var qstr = [],\n          expr,\n          parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n\n      if (parts.length > 2 || parts[0]) {\n        var i,\n            j,\n            list = [];\n\n        for (i = j = 0; i < parts.length; ++i) {\n\n          expr = parts[i];\n\n          if (expr && (expr = i & 1 ? _parseExpr(expr, 1, qstr) : '\"' + expr.replace(/\\\\/g, '\\\\\\\\').replace(/\\r\\n?|\\n/g, '\\\\n').replace(/\"/g, '\\\\\"') + '\"')) {\n            list[j++] = expr;\n          }\n        }\n\n        expr = j < 2 ? list[0] : '[' + list.join(',') + '].join(\"\")';\n      } else {\n\n        expr = _parseExpr(parts[1], 0, qstr);\n      }\n\n      if (qstr[0]) {\n        expr = expr.replace(RE_QBMARK, function (_, pos) {\n          return qstr[pos].replace(/\\r/g, '\\\\r').replace(/\\n/g, '\\\\n');\n        });\n      }\n      return expr;\n    }\n\n    var RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n    function _parseExpr(expr, asText, qstr) {\n\n      expr = expr.replace(RE_QBLOCK, function (s, div) {\n        return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s;\n      }).replace(/\\s+/g, ' ').trim().replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n      if (expr) {\n        var list = [],\n            cnt = 0,\n            match;\n\n        while (expr && (match = expr.match(RE_CSNAME)) && !match.index) {\n          var key,\n              jsb,\n              re = /,|([[{(])|$/g;\n\n          expr = RegExp.rightContext;\n          key = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n          while (jsb = (match = re.exec(expr))[1]) {\n            skipBraces(jsb, re);\n          }\n\n          jsb = expr.slice(0, match.index);\n          expr = RegExp.rightContext;\n\n          list[cnt++] = _wrapExpr(jsb, 1, key);\n        }\n\n        expr = !cnt ? _wrapExpr(expr, asText) : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n      }\n      return expr;\n\n      function skipBraces(ch, re) {\n        var mm,\n            lv = 1,\n            ir = RE_BREND[ch];\n\n        ir.lastIndex = re.lastIndex;\n        while (mm = ir.exec(expr)) {\n          if (mm[0] === ch) {\n            ++lv;\n          } else if (! --lv) {\n            break;\n          }\n        }\n        re.lastIndex = lv ? expr.length : ir.lastIndex;\n      }\n    }\n\n    // istanbul ignore next: not both\n    var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' ? 'global' : 'window') + ').',\n        JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n        JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n    function _wrapExpr(expr, asText, key) {\n      var tb;\n\n      expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n        if (mvar) {\n          pos = tb ? 0 : pos + match.length;\n\n          if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n            match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n            if (pos) {\n              tb = (s = s[pos]) === '.' || s === '(' || s === '[';\n            }\n          } else if (pos) {\n            tb = !JS_NOPROPS.test(s.slice(pos));\n          }\n        }\n        return match;\n      });\n\n      if (tb) {\n        expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n      }\n\n      if (key) {\n\n        expr = (tb ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')') + '?\"' + key + '\":\"\"';\n      } else if (asText) {\n\n        expr = 'function(v){' + (tb ? expr.replace('return ', 'v=') : 'v=(' + expr + ')') + ';return v||v===0?v:\"\"}.call(this)';\n      }\n\n      return expr;\n    }\n\n    _tmpl.version = brackets.version = 'v3.0.3';\n\n    return _tmpl;\n  }();\n\n  /* istanbul ignore next */\n  var observable$1 = function observable$1(el) {\n\n    /**\n     * Extend the original object or create a new empty one\n     * @type { Object }\n     */\n\n    el = el || {};\n\n    /**\n     * Private variables\n     */\n    var callbacks = {},\n        slice = Array.prototype.slice;\n\n    /**\n     * Public Api\n     */\n\n    // extend the el object adding the observable methods\n    Object.defineProperties(el, {\n      /**\n       * Listen to the given `event` ands\n       * execute the `callback` each time an event is triggered.\n       * @param  { String } event - event id\n       * @param  { Function } fn - callback function\n       * @returns { Object } el\n       */\n      on: {\n        value: function value(event, fn) {\n          if (typeof fn == 'function') {\n            (callbacks[event] = callbacks[event] || []).push(fn);\n          }\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Removes the given `event` listeners\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      off: {\n        value: function value(event, fn) {\n          if (event == '*' && !fn) {\n            callbacks = {};\n          } else {\n            if (fn) {\n              var arr = callbacks[event];\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn) {\n                  arr.splice(i--, 1);\n                }\n              }\n            } else {\n              delete callbacks[event];\n            }\n          }\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Listen to the given `event` and\n       * execute the `callback` at most once\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      one: {\n        value: function value(event, fn) {\n          function on() {\n            el.off(event, on);\n            fn.apply(el, arguments);\n          }\n          return el.on(event, on);\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Execute all callback functions that listen to\n       * the given `event`\n       * @param   { String } event - event id\n       * @returns { Object } el\n       */\n      trigger: {\n        value: function value(event) {\n          var arguments$1 = arguments;\n\n          // getting the arguments\n          var arglen = arguments.length - 1,\n              args = new Array(arglen),\n              fns,\n              fn,\n              i;\n\n          for (i = 0; i < arglen; i++) {\n            args[i] = arguments$1[i + 1]; // skip first argument\n          }\n\n          fns = slice.call(callbacks[event] || [], 0);\n\n          for (i = 0; fn = fns[i]; ++i) {\n            fn.apply(el, args);\n          }\n\n          if (callbacks['*'] && event != '*') {\n            el.trigger.apply(el, ['*', event].concat(args));\n          }\n\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      }\n    });\n\n    return el;\n  };\n\n  /**\n   * Specialized function for looping an array-like collection with `each={}`\n   * @param   { Array } list - collection of items\n   * @param   {Function} fn - callback function\n   * @returns { Array } the array looped\n   */\n  function each(list, fn) {\n    var len = list ? list.length : 0;\n    var i = 0;\n    for (; i < len; ++i) {\n      fn(list[i], i);\n    }\n    return list;\n  }\n\n  /**\n   * Check whether an array contains an item\n   * @param   { Array } array - target array\n   * @param   { * } item - item to test\n   * @returns { Boolean } -\n   */\n  function contains(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n\n  /**\n   * Convert a string containing dashes to camel case\n   * @param   { String } str - input string\n   * @returns { String } my-string -> myString\n   */\n  function toCamel(str) {\n    return str.replace(/-(\\w)/g, function (_, c) {\n      return c.toUpperCase();\n    });\n  }\n\n  /**\n   * Faster String startsWith alternative\n   * @param   { String } str - source string\n   * @param   { String } value - test string\n   * @returns { Boolean } -\n   */\n  function startsWith(str, value) {\n    return str.slice(0, value.length) === value;\n  }\n\n  /**\n   * Helper function to set an immutable property\n   * @param   { Object } el - object where the new property will be set\n   * @param   { String } key - object key where the new property will be stored\n   * @param   { * } value - value of the new property\n   * @param   { Object } options - set the propery overriding the default options\n   * @returns { Object } - the initial object\n   */\n  function defineProperty(el, key, value, options) {\n    Object.defineProperty(el, key, extend({\n      value: value,\n      enumerable: false,\n      writable: false,\n      configurable: true\n    }, options));\n    return el;\n  }\n\n  /**\n   * Extend any object with other properties\n   * @param   { Object } src - source object\n   * @returns { Object } the resulting extended object\n   *\n   * var obj = { foo: 'baz' }\n   * extend(obj, {bar: 'bar', foo: 'bar'})\n   * console.log(obj) => {bar: 'bar', foo: 'bar'}\n   *\n   */\n  function extend(src) {\n    var obj,\n        args = arguments;\n    for (var i = 1; i < args.length; ++i) {\n      if (obj = args[i]) {\n        for (var key in obj) {\n          // check if this property of the source object could be overridden\n          if (isWritable(src, key)) {\n            src[key] = obj[key];\n          }\n        }\n      }\n    }\n    return src;\n  }\n\n  var misc = Object.freeze({\n    each: each,\n    contains: contains,\n    toCamel: toCamel,\n    startsWith: startsWith,\n    defineProperty: defineProperty,\n    extend: extend\n  });\n\n  var settings$1 = extend(Object.create(brackets.settings), {\n    skipAnonymousTags: true\n  });\n\n  /**\n   * Trigger DOM events\n   * @param   { HTMLElement } dom - dom element target of the event\n   * @param   { Function } handler - user function\n   * @param   { Object } e - event object\n   */\n  function handleEvent(dom, handler, e) {\n    var ptag = this.__.parent,\n        item = this.__.item;\n\n    if (!item) {\n      while (ptag && !item) {\n        item = ptag.__.item;\n        ptag = ptag.__.parent;\n      }\n    }\n\n    // override the event properties\n    /* istanbul ignore next */\n    if (isWritable(e, 'currentTarget')) {\n      e.currentTarget = dom;\n    }\n    /* istanbul ignore next */\n    if (isWritable(e, 'target')) {\n      e.target = e.srcElement;\n    }\n    /* istanbul ignore next */\n    if (isWritable(e, 'which')) {\n      e.which = e.charCode || e.keyCode;\n    }\n\n    e.item = item;\n\n    handler.call(this, e);\n\n    if (!e.preventUpdate) {\n      var p = getImmediateCustomParentTag(this);\n      // fixes #2083\n      if (p.isMounted) {\n        p.update();\n      }\n    }\n  }\n\n  /**\n   * Attach an event to a DOM node\n   * @param { String } name - event name\n   * @param { Function } handler - event callback\n   * @param { Object } dom - dom node\n   * @param { Tag } tag - tag instance\n   */\n  function setEventHandler(name, handler, dom, tag) {\n    var eventName,\n        cb = handleEvent.bind(tag, dom, handler);\n\n    // normalize event name\n    eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n    // cache the listener into the listeners array\n    if (!contains(tag.__.listeners, dom)) {\n      tag.__.listeners.push(dom);\n    }\n    if (!dom[RIOT_EVENTS_KEY]) {\n      dom[RIOT_EVENTS_KEY] = {};\n    }\n    if (dom[RIOT_EVENTS_KEY][name]) {\n      dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]);\n    }\n\n    dom[RIOT_EVENTS_KEY][name] = cb;\n    dom.addEventListener(eventName, cb, false);\n  }\n\n  /**\n   * Update dynamically created data-is tags with changing expressions\n   * @param { Object } expr - expression tag and expression info\n   * @param { Tag }    parent - parent for tag creation\n   * @param { String } tagName - tag implementation we want to use\n   */\n  function updateDataIs(expr, parent, tagName) {\n    var conf, isVirtual, head, ref;\n\n    if (expr.tag && expr.tagName === tagName) {\n      expr.tag.update();\n      return;\n    }\n\n    isVirtual = expr.dom.tagName === 'VIRTUAL';\n    // sync _parent to accommodate changing tagnames\n    if (expr.tag) {\n\n      // need placeholder before unmount\n      if (isVirtual) {\n        head = expr.tag.__.head;\n        ref = createDOMPlaceholder();\n        head.parentNode.insertBefore(ref, head);\n      }\n\n      expr.tag.unmount(true);\n    }\n\n    expr.impl = __TAG_IMPL[tagName];\n    conf = { root: expr.dom, parent: parent, hasImpl: true, tagName: tagName };\n    expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n    each(expr.attrs, function (a) {\n      return setAttr(expr.tag.root, a.name, a.value);\n    });\n    expr.tagName = tagName;\n    expr.tag.mount();\n    if (isVirtual) {\n      makeReplaceVirtual(expr.tag, ref || expr.tag.root);\n    } // root exist first time, after use placeholder\n\n    // parent is the placeholder tag, not the dynamic tag so clean up\n    parent.__.onUnmount = function () {\n      var delName = expr.tag.opts.dataIs,\n          tags = expr.tag.parent.tags,\n          _tags = expr.tag.__.parent.tags;\n      arrayishRemove(tags, delName, expr.tag);\n      arrayishRemove(_tags, delName, expr.tag);\n      expr.tag.unmount();\n    };\n  }\n\n  /**\n   * Nomalize any attribute removing the \"riot-\" prefix\n   * @param   { String } attrName - original attribute name\n   * @returns { String } valid html attribute name\n   */\n  function normalizeAttrName(attrName) {\n    if (!attrName) {\n      return null;\n    }\n    attrName = attrName.replace(ATTRS_PREFIX, '');\n    if (CASE_SENSITIVE_ATTRIBUTES[attrName]) {\n      attrName = CASE_SENSITIVE_ATTRIBUTES[attrName];\n    }\n    return attrName;\n  }\n\n  /**\n   * Update on single tag expression\n   * @this Tag\n   * @param { Object } expr - expression logic\n   * @returns { undefined }\n   */\n  function updateExpression(expr) {\n    if (this.root && getAttr(this.root, 'virtualized')) {\n      return;\n    }\n\n    var dom = expr.dom,\n\n    // remove the riot- prefix\n    attrName = normalizeAttrName(expr.attr),\n        isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName),\n        isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n        parent = dom && (expr.parent || dom.parentNode),\n\n    // detect the style attributes\n    isStyleAttr = attrName === 'style',\n        isClassAttr = attrName === 'class',\n        isObj,\n        value;\n\n    // if it's a tag we could totally skip the rest\n    if (expr._riot_id) {\n      if (expr.isMounted) {\n        expr.update();\n        // if it hasn't been mounted yet, do that now.\n      } else {\n        expr.mount();\n        if (isVirtual) {\n          makeReplaceVirtual(expr, expr.root);\n        }\n      }\n      return;\n    }\n    // if this expression has the update method it means it can handle the DOM changes by itself\n    if (expr.update) {\n      return expr.update();\n    }\n\n    // ...it seems to be a simple expression so we try to calculat its value\n    value = tmpl(expr.expr, this);\n    isObj = isObject(value);\n\n    // convert the style/class objects to strings\n    if (isObj) {\n      isObj = !isClassAttr && !isStyleAttr;\n      if (isClassAttr) {\n        value = tmpl(JSON.stringify(value), this);\n      } else if (isStyleAttr) {\n        value = styleObjectToString(value);\n      }\n    }\n\n    // for the boolean attributes we don't need the value\n    // we can convert it to checked=true to checked=checked\n    if (expr.bool) {\n      value = value ? attrName : false;\n    }\n    if (expr.isRtag) {\n      return updateDataIs(expr, this, value);\n    }\n    if (expr.wasParsedOnce && expr.value === value) {\n      return;\n    }\n\n    // update the expression value\n    expr.value = value;\n    expr.wasParsedOnce = true;\n\n    // if the value is an object we can not do much more with it\n    if (isObj && !isToggle) {\n      return;\n    }\n    // avoid to render undefined/null values\n    if (isBlank(value)) {\n      value = '';\n    }\n\n    // textarea and text nodes have no attribute name\n    if (!attrName) {\n      // about #815 w/o replace: the browser converts the value to a string,\n      // the comparison by \"==\" does too, but not in the server\n      value += '';\n      // test for parent avoids error with invalid assignment to nodeValue\n      if (parent) {\n        // cache the parent node because somehow it will become null on IE\n        // on the next iteration\n        expr.parent = parent;\n        if (parent.tagName === 'TEXTAREA') {\n          parent.value = value; // #1113\n          if (!IE_VERSION) {\n            dom.nodeValue = value;\n          } // #1625 IE throws here, nodeValue\n        } // will be available on 'updated'\n        else {\n            dom.nodeValue = value;\n          }\n      }\n      return;\n    }\n\n    // remove original attribute\n    if (!expr.isAttrRemoved || !value) {\n      remAttr(dom, expr.attr);\n      expr.isAttrRemoved = true;\n    }\n\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, this);\n      // show / hide\n    } else if (isToggle) {\n      toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n      // handle attributes\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value;\n      }\n\n      if (attrName === 'value' && dom.value !== value) {\n        dom.value = value;\n      }\n\n      if (!isBlank(value) && value !== false) {\n        setAttr(dom, attrName, value);\n      }\n\n      // make sure that in case of style changes\n      // the element stays hidden\n      if (isStyleAttr && dom.hidden) {\n        toggleVisibility(dom, false);\n      }\n    }\n  }\n\n  /**\n   * Update all the expressions in a Tag instance\n   * @this Tag\n   * @param { Array } expressions - expression that must be re evaluated\n   */\n  function updateAllExpressions(expressions) {\n    each(expressions, updateExpression.bind(this));\n  }\n\n  var IfExpr = {\n    init: function init(dom, tag, expr) {\n      remAttr(dom, CONDITIONAL_DIRECTIVE);\n      this.tag = tag;\n      this.expr = expr;\n      this.stub = document.createTextNode('');\n      this.pristine = dom;\n\n      var p = dom.parentNode;\n      p.insertBefore(this.stub, dom);\n      p.removeChild(dom);\n\n      return this;\n    },\n    update: function update() {\n      this.value = tmpl(this.expr, this.tag);\n\n      if (this.value && !this.current) {\n        // insert\n        this.current = this.pristine.cloneNode(true);\n        this.stub.parentNode.insertBefore(this.current, this.stub);\n        this.expressions = [];\n        parseExpressions.apply(this.tag, [this.current, this.expressions, true]);\n      } else if (!this.value && this.current) {\n        // remove\n        unmountAll(this.expressions);\n        if (this.current._tag) {\n          this.current._tag.unmount();\n        } else if (this.current.parentNode) {\n          this.current.parentNode.removeChild(this.current);\n        }\n        this.current = null;\n        this.expressions = [];\n      }\n\n      if (this.value) {\n        updateAllExpressions.call(this.tag, this.expressions);\n      }\n    },\n    unmount: function unmount() {\n      unmountAll(this.expressions || []);\n      delete this.pristine;\n      delete this.parentNode;\n      delete this.stub;\n    }\n  };\n\n  var RefExpr = {\n    init: function init(dom, parent, attrName, attrValue) {\n      this.dom = dom;\n      this.attr = attrName;\n      this.rawValue = attrValue;\n      this.parent = parent;\n      this.hasExp = tmpl.hasExpr(attrValue);\n      return this;\n    },\n    update: function update() {\n      var old = this.value;\n      var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n      // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n      var tagOrDom = this.tag || this.dom;\n\n      this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n      // the name changed, so we need to remove it from the old key (if present)\n      if (!isBlank(old) && customParent) {\n        arrayishRemove(customParent.refs, old, tagOrDom);\n      }\n\n      if (isBlank(this.value)) {\n        // if the value is blank, we remove it\n        remAttr(this.dom, this.attr);\n      } else {\n        // add it to the refs of parent tag (this behavior was changed >=3.0)\n        if (customParent) {\n          arrayishAdd(customParent.refs, this.value, tagOrDom,\n          // use an array if it's a looped node and the ref is not an expression\n          null, this.parent.__.index);\n        }\n        // set the actual DOM attr\n        setAttr(this.dom, this.attr, this.value);\n      }\n    },\n    unmount: function unmount() {\n      var tagOrDom = this.tag || this.dom;\n      var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n      if (!isBlank(this.value) && customParent) {\n        arrayishRemove(customParent.refs, this.value, tagOrDom);\n      }\n      delete this.dom;\n      delete this.parent;\n    }\n  };\n\n  /**\n   * Convert the item looped into an object used to extend the child tag properties\n   * @param   { Object } expr - object containing the keys used to extend the children tags\n   * @param   { * } key - value to assign to the new object returned\n   * @param   { * } val - value containing the position of the item in the array\n   * @param   { Object } base - prototype object for the new item\n   * @returns { Object } - new object containing the values of the original item\n   *\n   * The variables 'key' and 'val' are arbitrary.\n   * They depend on the collection type looped (Array, Object)\n   * and on the expression used on the each tag\n   *\n   */\n  function mkitem(expr, key, val, base) {\n    var item = base ? Object.create(base) : {};\n    item[expr.key] = key;\n    if (expr.pos) {\n      item[expr.pos] = val;\n    }\n    return item;\n  }\n\n  /**\n   * Unmount the redundant tags\n   * @param   { Array } items - array containing the current items to loop\n   * @param   { Array } tags - array containing all the children tags\n   */\n  function unmountRedundant(items, tags) {\n    var i = tags.length,\n        j = items.length;\n\n    while (i > j) {\n      i--;\n      remove.apply(tags[i], [tags, i]);\n    }\n  }\n\n  /**\n   * Remove a child tag\n   * @this Tag\n   * @param   { Array } tags - tags collection\n   * @param   { Number } i - index of the tag to remove\n   */\n  function remove(tags, i) {\n    tags.splice(i, 1);\n    this.unmount();\n    arrayishRemove(this.parent, this, this.__.tagName, true);\n  }\n\n  /**\n   * Move the nested custom tags in non custom loop tags\n   * @this Tag\n   * @param   { Number } i - current position of the loop tag\n   */\n  function moveNestedTags(i) {\n    var this$1 = this;\n\n    each(Object.keys(this.tags), function (tagName) {\n      moveChildTag.apply(this$1.tags[tagName], [tagName, i]);\n    });\n  }\n\n  /**\n   * Move a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function move(root, nextTag, isVirtual) {\n    if (isVirtual) {\n      moveVirtual.apply(this, [root, nextTag]);\n    } else {\n      safeInsert(root, this.root, nextTag.root);\n    }\n  }\n\n  /**\n   * Insert and mount a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function insert(root, nextTag, isVirtual) {\n    if (isVirtual) {\n      makeVirtual.apply(this, [root, nextTag]);\n    } else {\n      safeInsert(root, this.root, nextTag.root);\n    }\n  }\n\n  /**\n   * Append a new tag into the DOM\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function append(root, isVirtual) {\n    if (isVirtual) {\n      makeVirtual.call(this, root);\n    } else {\n      root.appendChild(this.root);\n    }\n  }\n\n  /**\n   * Manage tags having the 'each'\n   * @param   { HTMLElement } dom - DOM node we need to loop\n   * @param   { Tag } parent - parent tag instance where the dom node is contained\n   * @param   { String } expr - string contained in the 'each' attribute\n   * @returns { Object } expression object for this each loop\n   */\n  function _each(dom, parent, expr) {\n\n    // remove the each property from the original tag\n    remAttr(dom, LOOP_DIRECTIVE);\n\n    var mustReorder = _typeof(getAttr(dom, LOOP_NO_REORDER_DIRECTIVE)) !== T_STRING || remAttr(dom, LOOP_NO_REORDER_DIRECTIVE),\n        tagName = getTagName(dom),\n        impl = __TAG_IMPL[tagName],\n        parentNode = dom.parentNode,\n        placeholder = createDOMPlaceholder(),\n        child = getTag(dom),\n        ifExpr = getAttr(dom, CONDITIONAL_DIRECTIVE),\n        tags = [],\n        oldItems = [],\n        hasKeys,\n        isLoop = true,\n        isAnonymous = !__TAG_IMPL[tagName],\n        isVirtual = dom.tagName === 'VIRTUAL';\n\n    // parse the each expression\n    expr = tmpl.loopKeys(expr);\n    expr.isLoop = true;\n\n    if (ifExpr) {\n      remAttr(dom, CONDITIONAL_DIRECTIVE);\n    }\n\n    // insert a marked where the loop tags will be injected\n    parentNode.insertBefore(placeholder, dom);\n    parentNode.removeChild(dom);\n\n    expr.update = function updateEach() {\n      // get the new items collection\n      expr.value = tmpl(expr.val, parent);\n\n      var frag = createFrag(),\n          items = expr.value,\n          isObject$$1 = !isArray(items) && !isString(items),\n          root = placeholder.parentNode;\n\n      // object loop. any changes cause full redraw\n      if (isObject$$1) {\n        hasKeys = items || false;\n        items = hasKeys ? Object.keys(items).map(function (key) {\n          return mkitem(expr, items[key], key);\n        }) : [];\n      } else {\n        hasKeys = false;\n      }\n\n      if (ifExpr) {\n        items = items.filter(function (item, i) {\n          if (expr.key && !isObject$$1) {\n            return !!tmpl(ifExpr, mkitem(expr, item, i, parent));\n          }\n\n          return !!tmpl(ifExpr, extend(Object.create(parent), item));\n        });\n      }\n\n      // loop all the new items\n      each(items, function (item, i) {\n        // reorder only if the items are objects\n        var doReorder = mustReorder && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === T_OBJECT && !hasKeys,\n            oldPos = oldItems.indexOf(item),\n            isNew = oldPos === -1,\n            pos = !isNew && doReorder ? oldPos : i,\n\n        // does a tag exist in this position?\n        tag = tags[pos],\n            mustAppend = i >= oldItems.length,\n            mustCreate = doReorder && isNew || !doReorder && !tag;\n\n        item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\n        // new tag\n        if (mustCreate) {\n          tag = new Tag$1(impl, {\n            parent: parent,\n            isLoop: isLoop,\n            isAnonymous: isAnonymous,\n            tagName: tagName,\n            root: dom.cloneNode(isAnonymous),\n            item: item,\n            index: i\n          }, dom.innerHTML);\n\n          // mount the tag\n          tag.mount();\n\n          if (mustAppend) {\n            append.apply(tag, [frag || root, isVirtual]);\n          } else {\n            insert.apply(tag, [root, tags[i], isVirtual]);\n          }\n\n          if (!mustAppend) {\n            oldItems.splice(i, 0, item);\n          }\n          tags.splice(i, 0, tag);\n          if (child) {\n            arrayishAdd(parent.tags, tagName, tag, true);\n          }\n        } else if (pos !== i && doReorder) {\n          // move\n          if (contains(items, oldItems[pos])) {\n            move.apply(tag, [root, tags[i], isVirtual]);\n            // move the old tag instance\n            tags.splice(i, 0, tags.splice(pos, 1)[0]);\n            // move the old item\n            oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n          }\n\n          // update the position attribute if it exists\n          if (expr.pos) {\n            tag[expr.pos] = i;\n          }\n\n          // if the loop tags are not custom\n          // we need to move all their custom tags into the right position\n          if (!child && tag.tags) {\n            moveNestedTags.call(tag, i);\n          }\n        }\n\n        // cache the original item to use it in the events bound to this node\n        // and its children\n        tag.__.item = item;\n        tag.__.index = i;\n        tag.__.parent = parent;\n\n        if (!mustCreate) {\n          tag.update(item);\n        }\n      });\n\n      // remove the redundant tags\n      unmountRedundant(items, tags);\n\n      // clone the items array\n      oldItems = items.slice();\n\n      root.insertBefore(frag, placeholder);\n    };\n\n    expr.unmount = function () {\n      each(tags, function (t) {\n        t.unmount();\n      });\n    };\n\n    return expr;\n  }\n\n  /**\n   * Walk the tag DOM to detect the expressions to evaluate\n   * @this Tag\n   * @param   { HTMLElement } root - root tag where we will start digging the expressions\n   * @param   { Array } expressions - empty array where the expressions will be added\n   * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n   * @returns { Object } an object containing the root noode and the dom tree\n   */\n  function parseExpressions(root, expressions, mustIncludeRoot) {\n    var this$1 = this;\n\n    var tree = { parent: { children: expressions } };\n\n    walkNodes(root, function (dom, ctx) {\n      var type = dom.nodeType,\n          parent = ctx.parent,\n          attr,\n          expr,\n          tagImpl;\n      if (!mustIncludeRoot && dom === root) {\n        return { parent: parent };\n      }\n\n      // text node\n      if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue)) {\n        parent.children.push({ dom: dom, expr: dom.nodeValue });\n      }\n\n      if (type !== 1) {\n        return ctx;\n      } // not an element\n\n      var isVirtual = dom.tagName === 'VIRTUAL';\n\n      // loop. each does it's own thing (for now)\n      if (attr = getAttr(dom, LOOP_DIRECTIVE)) {\n        if (isVirtual) {\n          setAttr(dom, 'loopVirtual', true);\n        } // ignore here, handled in _each\n        parent.children.push(_each(dom, this$1, attr));\n        return false;\n      }\n\n      // if-attrs become the new parent. Any following expressions (either on the current\n      // element, or below it) become children of this expression.\n      if (attr = getAttr(dom, CONDITIONAL_DIRECTIVE)) {\n        parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n        return false;\n      }\n\n      if (expr = getAttr(dom, IS_DIRECTIVE)) {\n        if (tmpl.hasExpr(expr)) {\n          parent.children.push({ isRtag: true, expr: expr, dom: dom, attrs: [].slice.call(dom.attributes) });\n          return false;\n        }\n      }\n\n      // if this is a tag, stop traversing here.\n      // we ignore the root, since parseExpressions is called while we're mounting that root\n      tagImpl = getTag(dom);\n      if (isVirtual) {\n        if (getAttr(dom, 'virtualized')) {\n          dom.parentElement.removeChild(dom);\n        } // tag created, remove from dom\n        if (!tagImpl && !getAttr(dom, 'virtualized') && !getAttr(dom, 'loopVirtual')) // ok to create virtual tag\n          {\n            tagImpl = { tmpl: dom.outerHTML };\n          }\n      }\n\n      if (tagImpl && (dom !== root || mustIncludeRoot)) {\n        if (isVirtual && !getAttr(dom, IS_DIRECTIVE)) {\n          // handled in update\n          // can not remove attribute like directives\n          // so flag for removal after creation to prevent maximum stack error\n          setAttr(dom, 'virtualized', true);\n\n          var tag = new Tag$1({ tmpl: dom.outerHTML }, { root: dom, parent: this$1 }, dom.innerHTML);\n          parent.children.push(tag); // no return, anonymous tag, keep parsing\n        } else {\n          var conf = { root: dom, parent: this$1, hasImpl: true };\n          parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n          return false;\n        }\n      }\n\n      // attribute expressions\n      parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {\n        if (!expr) {\n          return;\n        }\n        parent.children.push(expr);\n      }]);\n\n      // whatever the parent is, all child elements get the same parent.\n      // If this element had an if-attr, that's the parent for all child elements\n      return { parent: parent };\n    }, tree);\n  }\n\n  /**\n   * Calls `fn` for every attribute on an element. If that attr has an expression,\n   * it is also passed to fn.\n   * @this Tag\n   * @param   { HTMLElement } dom - dom node to parse\n   * @param   { Array } attrs - array of attributes\n   * @param   { Function } fn - callback to exec on any iteration\n   */\n  function parseAttributes(dom, attrs, fn) {\n    var this$1 = this;\n\n    each(attrs, function (attr) {\n      var name = attr.name,\n          bool = isBoolAttr(name),\n          expr;\n\n      if (contains(REF_DIRECTIVES, name)) {\n        expr = Object.create(RefExpr).init(dom, this$1, name, attr.value);\n      } else if (tmpl.hasExpr(attr.value)) {\n        expr = { dom: dom, expr: attr.value, attr: name, bool: bool };\n      }\n\n      fn(attr, expr);\n    });\n  }\n\n  /*\n    Includes hacks needed for the Internet Explorer version 9 and below\n    See: http://kangax.github.io/compat-table/es5/#ie8\n         http://codeplanet.io/dropping-ie8/\n  */\n\n  var reHasYield = /<yield\\b/i;\n  var reYieldAll = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\n  var reYieldSrc = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\n  var reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\n  var rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\n  var tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\n  var GENERIC = 'div';\n\n  /*\n    Creates the root element for table or select child elements:\n    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n  */\n  function specialTags(el, tmpl, tagName) {\n\n    var select = tagName[0] === 'o',\n        parent = select ? 'select>' : 'table>';\n\n    // trim() is important here, this ensures we don't have artifacts,\n    // so we can check if we have only one element inside the parent\n    el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n    parent = el.firstChild;\n\n    // returns the immediate parent if tr/th/td/col is the only element, if not\n    // returns the whole tree, as this can include additional elements\n    /* istanbul ignore next */\n    if (select) {\n      parent.selectedIndex = -1; // for IE9, compatible w/current riot behavior\n    } else {\n      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n      var tname = rootEls[tagName];\n      if (tname && parent.childElementCount === 1) {\n        parent = $(tname, parent);\n      }\n    }\n    return parent;\n  }\n\n  /*\n    Replace the yield tag from any tag template with the innerHTML of the\n    original tag in the page\n  */\n  function replaceYield(tmpl, html) {\n    // do nothing if no yield\n    if (!reHasYield.test(tmpl)) {\n      return tmpl;\n    }\n\n    // be careful with #1343 - string on the source having `$1`\n    var src = {};\n\n    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n      src[ref] = src[ref] || text; // preserve first definition\n      return '';\n    }).trim();\n\n    return tmpl.replace(reYieldDest, function (_, ref, def) {\n      // yield with from - to attrs\n      return src[ref] || def || '';\n    }).replace(reYieldAll, function (_, def) {\n      // yield without any \"from\"\n      return html || def || '';\n    });\n  }\n\n  /**\n   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n   *\n   * @param   { String } tmpl  - The template coming from the custom tag definition\n   * @param   { String } html - HTML content that comes from the DOM element where you\n   *           will mount the tag, mostly the original tag in the page\n   * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n   */\n  function mkdom(tmpl, html) {\n    var match = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n        tagName = match && match[1].toLowerCase(),\n        el = mkEl(GENERIC);\n\n    // replace all the yield tags with the tag inner html\n    tmpl = replaceYield(tmpl, html);\n\n    /* istanbul ignore next */\n    if (tblTags.test(tagName)) {\n      el = specialTags(el, tmpl, tagName);\n    } else {\n      setInnerHTML(el, tmpl);\n    }\n\n    return el;\n  }\n\n  /**\n   * Another way to create a riot tag a bit more es6 friendly\n   * @param { HTMLElement } el - tag DOM selector or DOM node/s\n   * @param { Object } opts - tag logic\n   * @returns { Tag } new riot tag instance\n   */\n  function Tag$2(el, opts) {\n    // get the tag properties from the class constructor\n    var ref = this;\n    var name = ref.name;\n    var tmpl = ref.tmpl;\n    var css = ref.css;\n    var attrs = ref.attrs;\n    var onCreate = ref.onCreate;\n    // register a new tag and cache the class prototype\n    if (!__TAG_IMPL[name]) {\n      tag$1(name, tmpl, css, attrs, onCreate);\n      // cache the class constructor\n      __TAG_IMPL[name].class = this.constructor;\n    }\n\n    // mount the tag using the class instance\n    mountTo(el, name, opts, this);\n    // inject the component css\n    if (css) {\n      styleManager.inject();\n    }\n\n    return this;\n  }\n\n  /**\n   * Create a new riot tag implementation\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n  function tag$1(name, tmpl, css, attrs, fn) {\n    if (isFunction(attrs)) {\n      fn = attrs;\n\n      if (/^[\\w\\-]+\\s?=/.test(css)) {\n        attrs = css;\n        css = '';\n      } else {\n        attrs = '';\n      }\n    }\n\n    if (css) {\n      if (isFunction(css)) {\n        fn = css;\n      } else {\n        styleManager.add(css);\n      }\n    }\n\n    name = name.toLowerCase();\n    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n    return name;\n  }\n\n  /**\n   * Create a new riot tag implementation (for use by the compiler)\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n  function tag2$1(name, tmpl, css, attrs, fn) {\n    if (css) {\n      styleManager.add(css, name);\n    }\n\n    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n    return name;\n  }\n\n  /**\n   * Mount a tag using a specific tag implementation\n   * @param   { * } selector - tag DOM selector or DOM node/s\n   * @param   { String } tagName - tag implementation name\n   * @param   { Object } opts - tag logic\n   * @returns { Array } new tags instances\n   */\n  function mount$1(selector, tagName, opts) {\n    var tags = [];\n\n    function pushTagsTo(root) {\n      if (root.tagName) {\n        var riotTag = getAttr(root, IS_DIRECTIVE);\n\n        // have tagName? force riot-tag to be the same\n        if (tagName && riotTag !== tagName) {\n          riotTag = tagName;\n          setAttr(root, IS_DIRECTIVE, tagName);\n        }\n\n        var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\n        if (tag) {\n          tags.push(tag);\n        }\n      } else if (root.length) {\n        each(root, pushTagsTo);\n      } // assume nodeList\n    }\n\n    // inject styles into DOM\n    styleManager.inject();\n\n    if (isObject(tagName)) {\n      opts = tagName;\n      tagName = 0;\n    }\n\n    var elem;\n    var allTags;\n\n    // crawl the DOM to find the tag\n    if (isString(selector)) {\n      selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = selectTags() :\n      // or just the ones named like the selector\n      selector + selectTags(selector.split(/, */));\n\n      // make sure to pass always a selector\n      // to the querySelectorAll function\n      elem = selector ? $$(selector) : [];\n    } else\n      // probably you have passed already a tag or a NodeList\n      {\n        elem = selector;\n      }\n\n    // select all the registered and mount them inside their root elements\n    if (tagName === '*') {\n      // get all custom tags\n      tagName = allTags || selectTags();\n      // if the root els it's just a single tag\n      if (elem.tagName) {\n        elem = $$(tagName, elem);\n      } else {\n        // select all the children for all the different root elements\n        var nodeList = [];\n\n        each(elem, function (_el) {\n          return nodeList.push($$(tagName, _el));\n        });\n\n        elem = nodeList;\n      }\n      // get rid of the tagName\n      tagName = 0;\n    }\n\n    pushTagsTo(elem);\n\n    return tags;\n  }\n\n  // Create a mixin that could be globally shared across all the tags\n  var mixins = {};\n  var globals = mixins[GLOBAL_MIXIN] = {};\n  var mixins_id = 0;\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String }  name - mixin name (global mixin if object)\n   * @param   { Object }  mix - mixin logic\n   * @param   { Boolean } g - is global?\n   * @returns { Object }  the mixin logic\n   */\n  function mixin$1(name, mix, g) {\n    // Unnamed global\n    if (isObject(name)) {\n      mixin$1(\"__unnamed_\" + mixins_id++, name, true);\n      return;\n    }\n\n    var store = g ? globals : mixins;\n\n    // Getter\n    if (!mix) {\n      if (isUndefined(store[name])) {\n        throw new Error('Unregistered mixin: ' + name);\n      }\n\n      return store[name];\n    }\n\n    // Setter\n    store[name] = isFunction(mix) ? extend(mix.prototype, store[name] || {}) && mix : extend(store[name] || {}, mix);\n  }\n\n  /**\n   * Update all the tags instances created\n   * @returns { Array } all the tags instances\n   */\n  function update$1() {\n    return each(__TAGS_CACHE, function (tag) {\n      return tag.update();\n    });\n  }\n\n  function unregister$1(name) {\n    delete __TAG_IMPL[name];\n  }\n\n  var version$1 = 'v3.4.1';\n\n  var core = Object.freeze({\n    Tag: Tag$2,\n    tag: tag$1,\n    tag2: tag2$1,\n    mount: mount$1,\n    mixin: mixin$1,\n    update: update$1,\n    unregister: unregister$1,\n    version: version$1\n  });\n\n  // counter to give a unique id to all the Tag instances\n  var __uid = 0;\n\n  /**\n   * We need to update opts for this tag. That requires updating the expressions\n   * in any attributes on the tag, and then copying the result onto opts.\n   * @this Tag\n   * @param   {Boolean} isLoop - is it a loop tag?\n   * @param   { Tag }  parent - parent tag node\n   * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n   * @param   { Object }  opts - tag options\n   * @param   { Array }  instAttrs - tag attributes array\n   */\n  function updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n    // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n    // (and only this case) we don't need to do updateOpts, because the regular parse\n    // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n    if (isLoop && isAnonymous) {\n      return;\n    }\n\n    var ctx = !isAnonymous && isLoop ? this : parent || this;\n    each(instAttrs, function (attr) {\n      if (attr.expr) {\n        updateAllExpressions.call(ctx, [attr.expr]);\n      }\n      // normalize the attribute names\n      opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n    });\n  }\n\n  /**\n   * Tag class\n   * @constructor\n   * @param { Object } impl - it contains the tag template, and logic\n   * @param { Object } conf - tag options\n   * @param { String } innerHTML - html that eventually we need to inject in the tag\n   */\n  function Tag$1(impl, conf, innerHTML) {\n    if (impl === void 0) impl = {};\n    if (conf === void 0) conf = {};\n\n    var opts = extend({}, conf.opts),\n        parent = conf.parent,\n        isLoop = conf.isLoop,\n        isAnonymous = !!conf.isAnonymous,\n        skipAnonymous = settings$1.skipAnonymousTags && isAnonymous,\n        item = cleanUpData(conf.item),\n        index = conf.index,\n        // available only for the looped nodes\n    instAttrs = [],\n        // All attributes on the Tag when it's first parsed\n    implAttrs = [],\n        // expressions on this type of Tag\n    expressions = [],\n        root = conf.root,\n        tagName = conf.tagName || getTagName(root),\n        isVirtual = tagName === 'virtual',\n        propsInSyncWithParent = [],\n        dom;\n\n    // make this tag observable\n    if (!skipAnonymous) {\n      observable$1(this);\n    }\n    // only call unmount if we have a valid __TAG_IMPL (has name property)\n    if (impl.name && root._tag) {\n      root._tag.unmount(true);\n    }\n\n    // not yet mounted\n    this.isMounted = false;\n\n    defineProperty(this, '__', {\n      isAnonymous: isAnonymous,\n      instAttrs: instAttrs,\n      innerHTML: innerHTML,\n      tagName: tagName,\n      index: index,\n      isLoop: isLoop,\n      // tags having event listeners\n      // it would be better to use weak maps here but we can not introduce breaking changes now\n      listeners: [],\n      // these vars will be needed only for the virtual tags\n      virts: [],\n      tail: null,\n      head: null,\n      parent: null,\n      item: null\n    });\n\n    // create a unique id to this tag\n    // it could be handy to use it also to improve the virtual dom rendering speed\n    defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n    defineProperty(this, 'root', root);\n    extend(this, { opts: opts }, item);\n    // protect the \"tags\" and \"refs\" property from being overridden\n    defineProperty(this, 'parent', parent || null);\n    defineProperty(this, 'tags', {});\n    defineProperty(this, 'refs', {});\n\n    dom = isLoop && isAnonymous ? root : mkdom(impl.tmpl, innerHTML, isLoop);\n\n    /**\n     * Update the tag expressions and options\n     * @param   { * }  data - data we want to use to extend the tag properties\n     * @returns { Tag } the current tag instance\n     */\n    defineProperty(this, 'update', function tagUpdate(data) {\n      var nextOpts = {},\n          canTrigger = this.isMounted && !skipAnonymous;\n\n      // make sure the data passed will not override\n      // the component core methods\n      data = cleanUpData(data);\n      extend(this, data);\n      updateOpts.apply(this, [isLoop, parent, isAnonymous, nextOpts, instAttrs]);\n\n      if (canTrigger && this.isMounted && isFunction(this.shouldUpdate) && !this.shouldUpdate(data, nextOpts)) {\n        return this;\n      }\n\n      // inherit properties from the parent, but only for isAnonymous tags\n      if (isLoop && isAnonymous) {\n        inheritFrom.apply(this, [this.parent, propsInSyncWithParent]);\n      }\n      extend(opts, nextOpts);\n      if (canTrigger) {\n        this.trigger('update', data);\n      }\n      updateAllExpressions.call(this, expressions);\n      if (canTrigger) {\n        this.trigger('updated');\n      }\n\n      return this;\n    }.bind(this));\n\n    /**\n     * Add a mixin to this tag\n     * @returns { Tag } the current tag instance\n     */\n    defineProperty(this, 'mixin', function tagMixin() {\n      var this$1 = this;\n\n      each(arguments, function (mix) {\n        var instance, obj;\n        var props = [];\n\n        // properties blacklisted and will not be bound to the tag instance\n        var propsBlacklist = ['init', '__proto__'];\n\n        mix = isString(mix) ? mixin$1(mix) : mix;\n\n        // check if the mixin is a function\n        if (isFunction(mix)) {\n          // create the new mixin instance\n          instance = new mix();\n        } else {\n          instance = mix;\n        }\n\n        var proto = Object.getPrototypeOf(instance);\n\n        // build multilevel prototype inheritance chain property list\n        do {\n          props = props.concat(Object.getOwnPropertyNames(obj || instance));\n        } while (obj = Object.getPrototypeOf(obj || instance));\n\n        // loop the keys in the function prototype or the all object keys\n        each(props, function (key) {\n          // bind methods to this\n          // allow mixins to override other properties/parent mixins\n          if (!contains(propsBlacklist, key)) {\n            // check for getters/setters\n            var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n            var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n            // apply method only if it does not already exist on the instance\n            if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n              Object.defineProperty(this$1, key, descriptor);\n            } else {\n              this$1[key] = isFunction(instance[key]) ? instance[key].bind(this$1) : instance[key];\n            }\n          }\n        });\n\n        // init method will be called automatically\n        if (instance.init) {\n          instance.init.bind(this$1)();\n        }\n      });\n      return this;\n    }.bind(this));\n\n    /**\n     * Mount the current tag instance\n     * @returns { Tag } the current tag instance\n     */\n    defineProperty(this, 'mount', function tagMount() {\n      var this$1 = this;\n\n      root._tag = this; // keep a reference to the tag just created\n\n      // Read all the attrs on this instance. This give us the info we need for updateOpts\n      parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n        if (!isAnonymous && RefExpr.isPrototypeOf(expr)) {\n          expr.tag = this$1;\n        }\n        attr.expr = expr;\n        instAttrs.push(attr);\n      }]);\n\n      // update the root adding custom attributes coming from the compiler\n      implAttrs = [];\n      walkAttrs(impl.attrs, function (k, v) {\n        implAttrs.push({ name: k, value: v });\n      });\n      parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n        if (expr) {\n          expressions.push(expr);\n        } else {\n          setAttr(root, attr.name, attr.value);\n        }\n      }]);\n\n      // initialiation\n      updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\n      // add global mixins\n      var globalMixin = mixin$1(GLOBAL_MIXIN);\n\n      if (globalMixin && !skipAnonymous) {\n        for (var i in globalMixin) {\n          if (globalMixin.hasOwnProperty(i)) {\n            this$1.mixin(globalMixin[i]);\n          }\n        }\n      }\n\n      if (impl.fn) {\n        impl.fn.call(this, opts);\n      }\n\n      if (!skipAnonymous) {\n        this.trigger('before-mount');\n      }\n\n      // parse layout after init. fn may calculate args for nested custom tags\n      parseExpressions.apply(this, [dom, expressions, isAnonymous]);\n\n      this.update(item);\n\n      if (!isAnonymous) {\n        while (dom.firstChild) {\n          root.appendChild(dom.firstChild);\n        }\n      }\n\n      defineProperty(this, 'root', root);\n      defineProperty(this, 'isMounted', true);\n\n      if (skipAnonymous) {\n        return;\n      }\n\n      // if it's not a child tag we can trigger its mount event\n      if (!this.parent) {\n        this.trigger('mount');\n      }\n      // otherwise we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n      else {\n          var p = getImmediateCustomParentTag(this.parent);\n          p.one(!p.isMounted ? 'mount' : 'updated', function () {\n            this$1.trigger('mount');\n          });\n        }\n\n      return this;\n    }.bind(this));\n\n    /**\n     * Unmount the tag instance\n     * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n     * @returns { Tag } the current tag instance\n     */\n    defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n      var this$1 = this;\n\n      var el = this.root,\n          p = el.parentNode,\n          ptag,\n          tagIndex = __TAGS_CACHE.indexOf(this);\n\n      if (!skipAnonymous) {\n        this.trigger('before-unmount');\n      }\n\n      // clear all attributes coming from the mounted tag\n      walkAttrs(impl.attrs, function (name) {\n        if (startsWith(name, ATTRS_PREFIX)) {\n          name = name.slice(ATTRS_PREFIX.length);\n        }\n        remAttr(root, name);\n      });\n\n      // remove all the event listeners\n      this.__.listeners.forEach(function (dom) {\n        Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n          dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n        });\n      });\n\n      // remove this tag instance from the global virtualDom variable\n      if (tagIndex !== -1) {\n        __TAGS_CACHE.splice(tagIndex, 1);\n      }\n\n      if (p || isVirtual) {\n        if (parent) {\n          ptag = getImmediateCustomParentTag(parent);\n\n          if (isVirtual) {\n            Object.keys(this.tags).forEach(function (tagName) {\n              arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n            });\n          } else {\n            arrayishRemove(ptag.tags, tagName, this);\n            if (parent !== ptag) // remove from _parent too\n              {\n                arrayishRemove(parent.tags, tagName, this);\n              }\n          }\n        } else {\n          // remove the tag contents\n          setInnerHTML(el, '');\n        }\n\n        if (p && !mustKeepRoot) {\n          p.removeChild(el);\n        }\n\n        // the data-is attributes isn't needed anymore, remove it\n        remAttr(el, IS_DIRECTIVE);\n      }\n\n      if (this.__.virts) {\n        each(this.__.virts, function (v) {\n          if (v.parentNode) {\n            v.parentNode.removeChild(v);\n          }\n        });\n      }\n\n      // allow expressions to unmount themselves\n      unmountAll(expressions);\n      each(instAttrs, function (a) {\n        return a.expr && a.expr.unmount && a.expr.unmount();\n      });\n\n      // custom internal unmount function to avoid relying on the observable\n      if (this.__.onUnmount) {\n        this.__.onUnmount();\n      }\n\n      if (!skipAnonymous) {\n        this.trigger('unmount');\n        this.off('*');\n      }\n\n      defineProperty(this, 'isMounted', false);\n\n      delete this.root._tag;\n\n      return this;\n    }.bind(this));\n  }\n\n  /**\n   * Detect the tag implementation by a DOM node\n   * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n   * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n   */\n  function getTag(dom) {\n    return dom.tagName && __TAG_IMPL[getAttr(dom, IS_DIRECTIVE) || getAttr(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()];\n  }\n\n  /**\n   * Inherit properties from a target tag instance\n   * @this Tag\n   * @param   { Tag } target - tag where we will inherit properties\n   * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n   */\n  function inheritFrom(target, propsInSyncWithParent) {\n    var this$1 = this;\n\n    each(Object.keys(target), function (k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\n      if (isUndefined(this$1[k]) || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) {\n          propsInSyncWithParent.push(k);\n        }\n        this$1[k] = target[k];\n      }\n    });\n  }\n\n  /**\n   * Move the position of a custom tag in its parent tag\n   * @this Tag\n   * @param   { String } tagName - key where the tag was stored\n   * @param   { Number } newPos - index where the new tag will be stored\n   */\n  function moveChildTag(tagName, newPos) {\n    var parent = this.parent,\n        tags;\n    // no parent no move\n    if (!parent) {\n      return;\n    }\n\n    tags = parent.tags[tagName];\n\n    if (isArray(tags)) {\n      tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]);\n    } else {\n      arrayishAdd(parent.tags, tagName, this);\n    }\n  }\n\n  /**\n   * Create a new child tag including it correctly into its parent\n   * @param   { Object } child - child tag implementation\n   * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n   * @param   { String } innerHTML - inner html of the child node\n   * @param   { Object } parent - instance of the parent tag including the child custom tag\n   * @returns { Object } instance of the new child tag just created\n   */\n  function initChildTag(child, opts, innerHTML, parent) {\n    var tag = new Tag$1(child, opts, innerHTML),\n        tagName = opts.tagName || getTagName(opts.root, true),\n        ptag = getImmediateCustomParentTag(parent);\n    // fix for the parent attribute in the looped elements\n    defineProperty(tag, 'parent', ptag);\n    // store the real parent tag\n    // in some cases this could be different from the custom parent tag\n    // for example in nested loops\n    tag.__.parent = parent;\n\n    // add this tag to the custom parent tag\n    arrayishAdd(ptag.tags, tagName, tag);\n\n    // and also to the real parent tag\n    if (ptag !== parent) {\n      arrayishAdd(parent.tags, tagName, tag);\n    }\n\n    // empty the child node once we got its template\n    // to avoid that its children get compiled multiple times\n    opts.root.innerHTML = '';\n\n    return tag;\n  }\n\n  /**\n   * Loop backward all the parents tree to detect the first custom parent tag\n   * @param   { Object } tag - a Tag instance\n   * @returns { Object } the instance of the first custom parent tag found\n   */\n  function getImmediateCustomParentTag(tag) {\n    var ptag = tag;\n    while (ptag.__.isAnonymous) {\n      if (!ptag.parent) {\n        break;\n      }\n      ptag = ptag.parent;\n    }\n    return ptag;\n  }\n\n  /**\n   * Trigger the unmount method on all the expressions\n   * @param   { Array } expressions - DOM expressions\n   */\n  function unmountAll(expressions) {\n    each(expressions, function (expr) {\n      if (expr instanceof Tag$1) {\n        expr.unmount(true);\n      } else if (expr.tagName) {\n        expr.tag.unmount(true);\n      } else if (expr.unmount) {\n        expr.unmount();\n      }\n    });\n  }\n\n  /**\n   * Get the tag name of any DOM node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n   * @returns { String } name to identify this dom node in riot\n   */\n  function getTagName(dom, skipDataIs) {\n    var child = getTag(dom),\n        namedTag = !skipDataIs && getAttr(dom, IS_DIRECTIVE);\n    return namedTag && !tmpl.hasExpr(namedTag) ? namedTag : child ? child.name : dom.tagName.toLowerCase();\n  }\n\n  /**\n   * With this function we avoid that the internal Tag methods get overridden\n   * @param   { Object } data - options we want to use to extend the tag instance\n   * @returns { Object } clean object without containing the riot internal reserved words\n   */\n  function cleanUpData(data) {\n    if (!(data instanceof Tag$1) && !(data && isFunction(data.trigger))) {\n      return data;\n    }\n\n    var o = {};\n    for (var key in data) {\n      if (!RE_RESERVED_NAMES.test(key)) {\n        o[key] = data[key];\n      }\n    }\n    return o;\n  }\n\n  /**\n   * Set the property of an object for a given key. If something already\n   * exists there, then it becomes an array containing both the old and new value.\n   * @param { Object } obj - object on which to set the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be set\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n   * @param { Number } index - add the new item in a certain array position\n   */\n  function arrayishAdd(obj, key, value, ensureArray, index) {\n    var dest = obj[key];\n    var isArr = isArray(dest);\n    var hasIndex = !isUndefined(index);\n\n    if (dest && dest === value) {\n      return;\n    }\n\n    // if the key was never set, set it once\n    if (!dest && ensureArray) {\n      obj[key] = [value];\n    } else if (!dest) {\n      obj[key] = value;\n    }\n    // if it was an array and not yet set\n    else {\n        if (isArr) {\n          var oldIndex = dest.indexOf(value);\n          // this item never changed its position\n          if (oldIndex === index) {\n            return;\n          }\n          // remove the item from its old position\n          if (oldIndex !== -1) {\n            dest.splice(oldIndex, 1);\n          }\n          // move or add the item\n          if (hasIndex) {\n            dest.splice(index, 0, value);\n          } else {\n            dest.push(value);\n          }\n        } else {\n          obj[key] = [dest, value];\n        }\n      }\n  }\n\n  /**\n   * Removes an item from an object at a given key. If the key points to an array,\n   * then the item is just removed from the array.\n   * @param { Object } obj - object on which to remove the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be removed\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n  */\n  function arrayishRemove(obj, key, value, ensureArray) {\n    if (isArray(obj[key])) {\n      var index = obj[key].indexOf(value);\n      if (index !== -1) {\n        obj[key].splice(index, 1);\n      }\n      if (!obj[key].length) {\n        delete obj[key];\n      } else if (obj[key].length === 1 && !ensureArray) {\n        obj[key] = obj[key][0];\n      }\n    } else {\n      delete obj[key];\n    } // otherwise just delete the key\n  }\n\n  /**\n   * Mount a tag creating new Tag instance\n   * @param   { Object } root - dom node where the tag will be mounted\n   * @param   { String } tagName - name of the riot tag we want to mount\n   * @param   { Object } opts - options to pass to the Tag instance\n   * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n   * @returns { Tag } a new Tag instance\n   */\n  function mountTo(root, tagName, opts, ctx) {\n    var impl = __TAG_IMPL[tagName],\n        implClass = __TAG_IMPL[tagName].class,\n        tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\n    // clear the inner html\n    root.innerHTML = '';\n\n    var conf = extend({ root: root, opts: opts }, { parent: opts ? opts.parent : null });\n\n    if (impl && root) {\n      Tag$1.apply(tag, [impl, conf, innerHTML]);\n    }\n\n    if (tag && tag.mount) {\n      tag.mount(true);\n      // add this tag to the virtualDom variable\n      if (!contains(__TAGS_CACHE, tag)) {\n        __TAGS_CACHE.push(tag);\n      }\n    }\n\n    return tag;\n  }\n\n  /**\n   * makes a tag virtual and replaces a reference in the dom\n   * @this Tag\n   * @param { tag } the tag to make virtual\n   * @param { ref } the dom reference location\n   */\n  function makeReplaceVirtual(tag, ref) {\n    var frag = createFrag();\n    makeVirtual.call(tag, frag);\n    ref.parentNode.replaceChild(frag, ref);\n  }\n\n  /**\n   * Adds the elements for a virtual tag\n   * @this Tag\n   * @param { Node } src - the node that will do the inserting or appending\n   * @param { Tag } target - only if inserting, insert before this tag's first child\n   */\n  function makeVirtual(src, target) {\n    var this$1 = this;\n\n    var head = createDOMPlaceholder(),\n        tail = createDOMPlaceholder(),\n        frag = createFrag(),\n        sib,\n        el;\n\n    this.root.insertBefore(head, this.root.firstChild);\n    this.root.appendChild(tail);\n\n    this.__.head = el = head;\n    this.__.tail = tail;\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n      this$1.__.virts.push(el); // hold for unmounting\n      el = sib;\n    }\n\n    if (target) {\n      src.insertBefore(frag, target.__.head);\n    } else {\n      src.appendChild(frag);\n    }\n  }\n\n  /**\n   * Move virtual tag and all child nodes\n   * @this Tag\n   * @param { Node } src  - the node that will do the inserting\n   * @param { Tag } target - insert before this tag's first child\n   */\n  function moveVirtual(src, target) {\n    var this$1 = this;\n\n    var el = this.__.head,\n        frag = createFrag(),\n        sib;\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n      el = sib;\n      if (el === this$1.__.tail) {\n        frag.appendChild(el);\n        src.insertBefore(frag, target.__.head);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Get selectors for tags\n   * @param   { Array } tags - tag names to select\n   * @returns { String } selector\n   */\n  function selectTags(tags) {\n    // select all tags\n    if (!tags) {\n      var keys = Object.keys(__TAG_IMPL);\n      return keys + selectTags(keys);\n    }\n\n    return tags.filter(function (t) {\n      return !/[^-\\w]/.test(t);\n    }).reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\";\n    }, '');\n  }\n\n  var tags = Object.freeze({\n    getTag: getTag,\n    inheritFrom: inheritFrom,\n    moveChildTag: moveChildTag,\n    initChildTag: initChildTag,\n    getImmediateCustomParentTag: getImmediateCustomParentTag,\n    unmountAll: unmountAll,\n    getTagName: getTagName,\n    cleanUpData: cleanUpData,\n    arrayishAdd: arrayishAdd,\n    arrayishRemove: arrayishRemove,\n    mountTo: mountTo,\n    makeReplaceVirtual: makeReplaceVirtual,\n    makeVirtual: makeVirtual,\n    moveVirtual: moveVirtual,\n    selectTags: selectTags\n  });\n\n  /**\n   * Riot public api\n   */\n  var settings = settings$1;\n  var util = {\n    tmpl: tmpl,\n    brackets: brackets,\n    styleManager: styleManager,\n    vdom: __TAGS_CACHE,\n    styleNode: styleManager.styleNode,\n    // export the riot internal utils as well\n    dom: dom,\n    check: check,\n    misc: misc,\n    tags: tags\n  };\n\n  // export the core props/methods\n  var Tag$$1 = Tag$2;\n  var tag$$1 = tag$1;\n  var tag2$$1 = tag2$1;\n  var mount$$1 = mount$1;\n  var mixin$$1 = mixin$1;\n  var update$$1 = update$1;\n  var unregister$$1 = unregister$1;\n  var version$$1 = version$1;\n  var observable = observable$1;\n\n  var riot$1 = extend({}, core, {\n    observable: observable$1,\n    settings: settings,\n    util: util\n  });\n\n  exports.settings = settings;\n  exports.util = util;\n  exports.Tag = Tag$$1;\n  exports.tag = tag$$1;\n  exports.tag2 = tag2$$1;\n  exports.mount = mount$$1;\n  exports.mixin = mixin$$1;\n  exports.update = update$$1;\n  exports.unregister = unregister$$1;\n  exports.version = version$$1;\n  exports.observable = observable;\n  exports['default'] = riot$1;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_riot__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_riot___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_riot__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tags_app_tag__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tags_app_tag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__tags_app_tag__);\n\n\n\n__WEBPACK_IMPORTED_MODULE_0_riot___default.a.mount('app');\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar map = {\n\t\"./index.html\": 5\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 3;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__app_js__ = __webpack_require__(1);\n\n\n__webpack_require__(3);\n__webpack_require__(2);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__.p + \"index.html\";\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var riot = __webpack_require__(0)\n    riot.tag2('app', '<h1>asdASDA</h1> <p>ASd</p>', '', '', function(opts) {\n        console.log('I am tag!');\n});\n    \n  \n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// scripts/main.bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d757b5cb211cde3cc3f4","/* Riot v3.4.1, @license MIT */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.riot = global.riot || {})));\n}(this, (function (exports) { 'use strict';\n\nvar __TAGS_CACHE = [];\nvar __TAG_IMPL = {};\nvar GLOBAL_MIXIN = '__global_mixin';\nvar ATTRS_PREFIX = 'riot-';\nvar REF_DIRECTIVES = ['ref', 'data-ref'];\nvar IS_DIRECTIVE = 'data-is';\nvar CONDITIONAL_DIRECTIVE = 'if';\nvar LOOP_DIRECTIVE = 'each';\nvar LOOP_NO_REORDER_DIRECTIVE = 'no-reorder';\nvar SHOW_DIRECTIVE = 'show';\nvar HIDE_DIRECTIVE = 'hide';\nvar RIOT_EVENTS_KEY = '__riot-events__';\nvar T_STRING = 'string';\nvar T_OBJECT = 'object';\nvar T_UNDEF  = 'undefined';\nvar T_FUNCTION = 'function';\nvar XLINK_NS = 'http://www.w3.org/1999/xlink';\nvar XLINK_REGEX = /^xlink:(\\w+)/;\nvar WIN = typeof window === T_UNDEF ? undefined : window;\nvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\nvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\nvar RE_EVENTS_PREFIX = /^on/;\nvar RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\nvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\nvar CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\nvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\nvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\n/**\n * Check Check if the passed argument is undefined\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isBoolAttr(value) {\n  return RE_BOOL_ATTRS.test(value)\n}\n\n/**\n * Check if passed argument is a function\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isFunction(value) {\n  return typeof value === T_FUNCTION\n}\n\n/**\n * Check if passed argument is an object, exclude null\n * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isObject(value) {\n  return value && typeof value === T_OBJECT // typeof null is 'object'\n}\n\n/**\n * Check if passed argument is undefined\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isUndefined(value) {\n  return typeof value === T_UNDEF\n}\n\n/**\n * Check if passed argument is a string\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isString(value) {\n  return typeof value === T_STRING\n}\n\n/**\n * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n * @param { * } value -\n * @returns { Boolean } -\n */\nfunction isBlank(value) {\n  return isUndefined(value) || value === null || value === ''\n}\n\n/**\n * Check if passed argument is a kind of array\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isArray(value) {\n  return Array.isArray(value) || value instanceof Array\n}\n\n/**\n * Check whether object's property could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } -\n */\nfunction isWritable(obj, key) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  return isUndefined(obj[key]) || descriptor && descriptor.writable\n}\n\n/**\n * Check if passed argument is a reserved name\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isReservedName(value) {\n  return RE_RESERVED_NAMES.test(value)\n}\n\nvar check = Object.freeze({\n\tisBoolAttr: isBoolAttr,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisUndefined: isUndefined,\n\tisString: isString,\n\tisBlank: isBlank,\n\tisArray: isArray,\n\tisWritable: isWritable,\n\tisReservedName: isReservedName\n});\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Create a document fragment\n * @returns { Object } document fragment\n */\nfunction createFrag() {\n  return document.createDocumentFragment()\n}\n\n/**\n * Create a document text node\n * @returns { Object } create a text node to use as placeholder\n */\nfunction createDOMPlaceholder() {\n  return document.createTextNode('')\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we'll inject new html\n * @param { String } html - html to inject\n */\n/* istanbul ignore next */\nfunction setInnerHTML(container, html) {\n  if (!isUndefined(container.innerHTML))\n    { container.innerHTML = html; }\n    // some browsers do not support innerHTML on the SVGs tags\n  else {\n    var doc = new DOMParser().parseFromString(html, 'application/xml');\n    var node = container.ownerDocument.importNode(doc.documentElement, true);\n    container.appendChild(node);\n  }\n}\n\n/**\n * Toggle the visibility of any DOM node\n * @param   { Object }  dom - DOM node we want to hide\n * @param   { Boolean } show - do we want to show it?\n */\n\nfunction toggleVisibility(dom, show) {\n  dom.style.display = show ? '' : 'none';\n  dom['hidden'] = show ? false : true;\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name);\n}\n\n/**\n * Convert a style object to a string\n * @param   { Object } style - style object we need to parse\n * @returns { String } resulting css string\n * @example\n * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n */\nfunction styleObjectToString(style) {\n  return Object.keys(style).reduce(function (acc, prop) {\n    return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n  }, '')\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name);\n  if (xlink && xlink[1])\n    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n  else\n    { dom.setAttribute(name, val); }\n}\n\n/**\n * Insert safely a tag to fix #1962 #1649\n * @param   { HTMLElement } root - children container\n * @param   { HTMLElement } curr - node to insert\n * @param   { HTMLElement } next - node that should preceed the current node inserted\n */\nfunction safeInsert(root, curr, next) {\n  root.insertBefore(curr, next.parentNode && next);\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttrs(html, fn) {\n  if (!html)\n    { return }\n  var m;\n  while (m = RE_HTML_ATTRS.exec(html))\n    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n * @param   { Object }   context - fn can optionally return an object, which is passed to children\n */\nfunction walkNodes(dom, fn, context) {\n  if (dom) {\n    var res = fn(dom, context);\n    var next;\n    // stop the recursion\n    if (res === false) { return }\n\n    dom = dom.firstChild;\n\n    while (dom) {\n      next = dom.nextSibling;\n      walkNodes(dom, fn, res);\n      dom = next;\n    }\n  }\n}\n\nvar dom = Object.freeze({\n\t$$: $$,\n\t$: $,\n\tcreateFrag: createFrag,\n\tcreateDOMPlaceholder: createDOMPlaceholder,\n\tmkEl: mkEl,\n\tsetInnerHTML: setInnerHTML,\n\ttoggleVisibility: toggleVisibility,\n\tremAttr: remAttr,\n\tstyleObjectToString: styleObjectToString,\n\tgetAttr: getAttr,\n\tsetAttr: setAttr,\n\tsafeInsert: safeInsert,\n\twalkAttrs: walkAttrs,\n\twalkNodes: walkNodes\n});\n\nvar styleNode;\nvar cssTextProp;\nvar byName = {};\nvar remainder = [];\nvar needsInject = false;\n\n// skip the following code on the server\nif (WIN) {\n  styleNode = (function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style');\n    setAttr(newNode, 'type', 'text/css');\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]');\n    /* istanbul ignore next */\n    if (userNode) {\n      if (userNode.id) { newNode.id = userNode.id; }\n      userNode.parentNode.replaceChild(newNode, userNode);\n    }\n    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\n    return newNode\n  })();\n  cssTextProp = styleNode.styleSheet;\n}\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = {\n  styleNode: styleNode,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { String } css - css string\n   * @param { String } name - if it's passed we will map the css to a tagname\n   */\n  add: function add(css, name) {\n    if (name) { byName[name] = css; }\n    else { remainder.push(css); }\n    needsInject = true;\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   */\n  inject: function inject() {\n    if (!WIN || !needsInject) { return }\n    needsInject = false;\n    var style = Object.keys(byName)\n      .map(function(k) { return byName[k] })\n      .concat(remainder).join('\\n');\n    /* istanbul ignore next */\n    if (cssTextProp) { cssTextProp.cssText = style; }\n    else { styleNode.innerHTML = style; }\n  }\n};\n\n/**\n * The riot template engine\n * @version v3.0.3\n */\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\n/* global riot */\n\n/* istanbul ignore next */\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n    },\n\n    DEFAULT = '{ }';\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ];\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings;\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) { bp = _cache; }\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) { return _pairs }\n\n    var arr = pair.split(' ');\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n    arr[6] = _rewrite(_pairs[6], arr);\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);\n    arr[8] = pair;\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) { _bp = _cache; }\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6];\n\n    isexpr = start = re.lastIndex = 0;\n\n    while ((match = re.exec(str))) {\n\n      pos = match.index;\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(str, match[2], re.lastIndex);\n          continue\n        }\n        if (!match[3]) {\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos));\n        start = re.lastIndex;\n        re = _bp[6 + (isexpr ^= 1)];\n        re.lastIndex = start;\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start));\n    }\n\n    return parts\n\n    function unescapeStr (s) {\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'));\n      } else {\n        parts.push(s);\n      }\n    }\n\n    function skipBraces (s, ch, ix) {\n      var\n        match,\n        recch = FINDBRACES[ch];\n\n      recch.lastIndex = ix;\n      ix = 1;\n      while ((match = recch.exec(s))) {\n        if (match[1] &&\n          !(match[1] === ch ? ++ix : --ix)) { break }\n      }\n      return ix ? s.length : recch.lastIndex\n    }\n  };\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  };\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9]);\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  };\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  };\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair);\n      _regex = pair === DEFAULT ? _loopback : _rewrite;\n      _cache[9] = _regex(_pairs[9]);\n    }\n    cachedBrackets = pair;\n  }\n\n  function _setSettings (o) {\n    var b;\n\n    o = o || {};\n    b = o.brackets;\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    });\n    _settings = o;\n    _reset(b);\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  });\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n  _brackets.set = _reset;\n\n  _brackets.R_STRINGS = R_STRINGS;\n  _brackets.R_MLCOMMS = R_MLCOMMS;\n  _brackets.S_QBLOCKS = S_QBLOCKS;\n\n  return _brackets\n\n})();\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\n/* istanbul ignore next */\nvar tmpl = (function () {\n\n  var _cache = {};\n\n  function _tmpl (str, data) {\n    if (!str) { return str }\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr;\n\n  _tmpl.loopKeys = brackets.loopKeys;\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {}; };\n\n  _tmpl.errorHandler = null;\n\n  function _logErr (err, ctx) {\n\n    err.riotData = {\n      tagName: ctx && ctx.__ && ctx.__.tagName,\n      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n    };\n\n    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n    else if (\n      typeof console !== 'undefined' &&\n      typeof console.error === 'function'\n    ) {\n      if (err.riotData.tagName) {\n        console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName);\n      }\n      console.error(err);\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str);\n\n    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var\n    CH_IDEXPR = String.fromCharCode(0x2057),\n    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_DQUOTE = /\\u2057/g,\n    RE_QBMARK = /\\u2057(\\d+)~/g;\n\n  function _getTmpl (str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = [];\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i];\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) { list[j++] = expr; }\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")';\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr);\n    }\n\n    if (qstr[0]) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      });\n    }\n    return expr\n  }\n\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match;\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g;\n\n        expr = RegExp.rightContext;\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n        jsb  = expr.slice(0, match.index);\n        expr = RegExp.rightContext;\n\n        list[cnt++] = _wrapExpr(jsb, 1, key);\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch];\n\n      ir.lastIndex = re.lastIndex;\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) { ++lv; }\n        else if (!--lv) { break }\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex;\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n  function _wrapExpr (expr, asText, key) {\n    var tb;\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length;\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos));\n        }\n      }\n      return match\n    });\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"';\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)';\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v3.0.3';\n\n  return _tmpl\n\n})();\n\n/* istanbul ignore next */\nvar observable$1 = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {};\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice;\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          { (callbacks[event] = callbacks[event] || []).push(fn); }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) { callbacks = {}; }\n        else {\n          if (fn) {\n            var arr = callbacks[event];\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) { arr.splice(i--, 1); }\n            }\n          } else { delete callbacks[event]; }\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on);\n          fn.apply(el, arguments);\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n        var arguments$1 = arguments;\n\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i;\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments$1[i + 1]; // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0);\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args);\n        }\n\n        if (callbacks['*'] && event != '*')\n          { el.trigger.apply(el, ['*', event].concat(args)); }\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  });\n\n  return el\n\n};\n\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } list - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(list, fn) {\n  var len = list ? list.length : 0;\n  var i = 0;\n  for (; i < len; ++i) {\n    fn(list[i], i);\n  }\n  return list\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } array - target array\n * @param   { * } item - item to test\n * @returns { Boolean } -\n */\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } str - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(str) {\n  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } str - source string\n * @param   { String } value - test string\n * @returns { Boolean } -\n */\nfunction startsWith(str, value) {\n  return str.slice(0, value.length) === value\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n * @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return el\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments;\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          { src[key] = obj[key]; }\n      }\n    }\n  }\n  return src\n}\n\nvar misc = Object.freeze({\n\teach: each,\n\tcontains: contains,\n\ttoCamel: toCamel,\n\tstartsWith: startsWith,\n\tdefineProperty: defineProperty,\n\textend: extend\n});\n\nvar settings$1 = extend(Object.create(brackets.settings), {\n  skipAnonymousTags: true\n});\n\n/**\n * Trigger DOM events\n * @param   { HTMLElement } dom - dom element target of the event\n * @param   { Function } handler - user function\n * @param   { Object } e - event object\n */\nfunction handleEvent(dom, handler, e) {\n  var ptag = this.__.parent,\n    item = this.__.item;\n\n  if (!item)\n    { while (ptag && !item) {\n      item = ptag.__.item;\n      ptag = ptag.__.parent;\n    } }\n\n  // override the event properties\n  /* istanbul ignore next */\n  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n  e.item = item;\n\n  handler.call(this, e);\n\n  if (!e.preventUpdate) {\n    var p = getImmediateCustomParentTag(this);\n    // fixes #2083\n    if (p.isMounted) { p.update(); }\n  }\n}\n\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n  var eventName,\n    cb = handleEvent.bind(tag, dom, handler);\n\n  // normalize event name\n  eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n  // cache the listener into the listeners array\n  if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n  if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n  if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\n  dom[RIOT_EVENTS_KEY][name] = cb;\n  dom.addEventListener(eventName, cb, false);\n}\n\n/**\n * Update dynamically created data-is tags with changing expressions\n * @param { Object } expr - expression tag and expression info\n * @param { Tag }    parent - parent for tag creation\n * @param { String } tagName - tag implementation we want to use\n */\nfunction updateDataIs(expr, parent, tagName) {\n  var conf, isVirtual, head, ref;\n\n  if (expr.tag && expr.tagName === tagName) {\n    expr.tag.update();\n    return\n  }\n\n  isVirtual = expr.dom.tagName === 'VIRTUAL';\n  // sync _parent to accommodate changing tagnames\n  if (expr.tag) {\n\n    // need placeholder before unmount\n    if(isVirtual) {\n      head = expr.tag.__.head;\n      ref = createDOMPlaceholder();\n      head.parentNode.insertBefore(ref, head);\n    }\n\n    expr.tag.unmount(true);\n  }\n\n  expr.impl = __TAG_IMPL[tagName];\n  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};\n  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n  each(expr.attrs, function (a) { return setAttr(expr.tag.root, a.name, a.value); });\n  expr.tagName = tagName;\n  expr.tag.mount();\n  if (isVirtual)\n    { makeReplaceVirtual(expr.tag, ref || expr.tag.root); } // root exist first time, after use placeholder\n\n  // parent is the placeholder tag, not the dynamic tag so clean up\n  parent.__.onUnmount = function() {\n    var delName = expr.tag.opts.dataIs,\n      tags = expr.tag.parent.tags,\n      _tags = expr.tag.__.parent.tags;\n    arrayishRemove(tags, delName, expr.tag);\n    arrayishRemove(_tags, delName, expr.tag);\n    expr.tag.unmount();\n  };\n}\n\n/**\n * Nomalize any attribute removing the \"riot-\" prefix\n * @param   { String } attrName - original attribute name\n * @returns { String } valid html attribute name\n */\nfunction normalizeAttrName(attrName) {\n  if (!attrName) { return null }\n  attrName = attrName.replace(ATTRS_PREFIX, '');\n  if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n  return attrName\n}\n\n/**\n * Update on single tag expression\n * @this Tag\n * @param { Object } expr - expression logic\n * @returns { undefined }\n */\nfunction updateExpression(expr) {\n  if (this.root && getAttr(this.root,'virtualized')) { return }\n\n  var dom = expr.dom,\n    // remove the riot- prefix\n    attrName = normalizeAttrName(expr.attr),\n    isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName),\n    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n    parent = dom && (expr.parent || dom.parentNode),\n    // detect the style attributes\n    isStyleAttr = attrName === 'style',\n    isClassAttr = attrName === 'class',\n    isObj,\n    value;\n\n  // if it's a tag we could totally skip the rest\n  if (expr._riot_id) {\n    if (expr.isMounted) {\n      expr.update();\n    // if it hasn't been mounted yet, do that now.\n    } else {\n      expr.mount();\n      if (isVirtual) {\n        makeReplaceVirtual(expr, expr.root);\n      }\n    }\n    return\n  }\n  // if this expression has the update method it means it can handle the DOM changes by itself\n  if (expr.update) { return expr.update() }\n\n  // ...it seems to be a simple expression so we try to calculat its value\n  value = tmpl(expr.expr, this);\n  isObj = isObject(value);\n\n  // convert the style/class objects to strings\n  if (isObj) {\n    isObj = !isClassAttr && !isStyleAttr;\n    if (isClassAttr) {\n      value = tmpl(JSON.stringify(value), this);\n    } else if (isStyleAttr) {\n      value = styleObjectToString(value);\n    }\n  }\n\n  // for the boolean attributes we don't need the value\n  // we can convert it to checked=true to checked=checked\n  if (expr.bool) { value = value ? attrName : false; }\n  if (expr.isRtag) { return updateDataIs(expr, this, value) }\n  if (expr.wasParsedOnce && expr.value === value) { return }\n\n  // update the expression value\n  expr.value = value;\n  expr.wasParsedOnce = true;\n\n  // if the value is an object we can not do much more with it\n  if (isObj && !isToggle) { return }\n  // avoid to render undefined/null values\n  if (isBlank(value)) { value = ''; }\n\n  // textarea and text nodes have no attribute name\n  if (!attrName) {\n    // about #815 w/o replace: the browser converts the value to a string,\n    // the comparison by \"==\" does too, but not in the server\n    value += '';\n    // test for parent avoids error with invalid assignment to nodeValue\n    if (parent) {\n      // cache the parent node because somehow it will become null on IE\n      // on the next iteration\n      expr.parent = parent;\n      if (parent.tagName === 'TEXTAREA') {\n        parent.value = value;                    // #1113\n        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n      }                                         // will be available on 'updated'\n      else { dom.nodeValue = value; }\n    }\n    return\n  }\n\n  // remove original attribute\n  if (!expr.isAttrRemoved || !value) {\n    remAttr(dom, expr.attr);\n    expr.isAttrRemoved = true;\n  }\n\n  // event handler\n  if (isFunction(value)) {\n    setEventHandler(attrName, value, dom, this);\n  // show / hide\n  } else if (isToggle) {\n    toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n  // handle attributes\n  } else {\n    if (expr.bool) {\n      dom[attrName] = value;\n    }\n\n    if (attrName === 'value' && dom.value !== value) {\n      dom.value = value;\n    }\n\n    if (!isBlank(value) && value !== false) {\n      setAttr(dom, attrName, value);\n    }\n\n    // make sure that in case of style changes\n    // the element stays hidden\n    if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n  }\n}\n\n/**\n * Update all the expressions in a Tag instance\n * @this Tag\n * @param { Array } expressions - expression that must be re evaluated\n */\nfunction updateAllExpressions(expressions) {\n  each(expressions, updateExpression.bind(this));\n}\n\nvar IfExpr = {\n  init: function init(dom, tag, expr) {\n    remAttr(dom, CONDITIONAL_DIRECTIVE);\n    this.tag = tag;\n    this.expr = expr;\n    this.stub = document.createTextNode('');\n    this.pristine = dom;\n\n    var p = dom.parentNode;\n    p.insertBefore(this.stub, dom);\n    p.removeChild(dom);\n\n    return this\n  },\n  update: function update() {\n    this.value = tmpl(this.expr, this.tag);\n\n    if (this.value && !this.current) { // insert\n      this.current = this.pristine.cloneNode(true);\n      this.stub.parentNode.insertBefore(this.current, this.stub);\n      this.expressions = [];\n      parseExpressions.apply(this.tag, [this.current, this.expressions, true]);\n    } else if (!this.value && this.current) { // remove\n      unmountAll(this.expressions);\n      if (this.current._tag) {\n        this.current._tag.unmount();\n      } else if (this.current.parentNode) {\n        this.current.parentNode.removeChild(this.current);\n      }\n      this.current = null;\n      this.expressions = [];\n    }\n\n    if (this.value) { updateAllExpressions.call(this.tag, this.expressions); }\n  },\n  unmount: function unmount() {\n    unmountAll(this.expressions || []);\n    delete this.pristine;\n    delete this.parentNode;\n    delete this.stub;\n  }\n};\n\nvar RefExpr = {\n  init: function init(dom, parent, attrName, attrValue) {\n    this.dom = dom;\n    this.attr = attrName;\n    this.rawValue = attrValue;\n    this.parent = parent;\n    this.hasExp = tmpl.hasExpr(attrValue);\n    return this\n  },\n  update: function update() {\n    var old = this.value;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n    var tagOrDom = this.tag || this.dom;\n\n    this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n    // the name changed, so we need to remove it from the old key (if present)\n    if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n\n    if (isBlank(this.value)) {\n      // if the value is blank, we remove it\n      remAttr(this.dom, this.attr);\n    } else {\n      // add it to the refs of parent tag (this behavior was changed >=3.0)\n      if (customParent) { arrayishAdd(\n        customParent.refs,\n        this.value,\n        tagOrDom,\n        // use an array if it's a looped node and the ref is not an expression\n        null,\n        this.parent.__.index\n      ); }\n      // set the actual DOM attr\n      setAttr(this.dom, this.attr, this.value);\n    }\n  },\n  unmount: function unmount() {\n    var tagOrDom = this.tag || this.dom;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n    delete this.dom;\n    delete this.parent;\n  }\n};\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @param   { Object } base - prototype object for the new item\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val, base) {\n  var item = base ? Object.create(base) : {};\n  item[expr.key] = key;\n  if (expr.pos) { item[expr.pos] = val; }\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n  var i = tags.length,\n    j = items.length;\n\n  while (i > j) {\n    i--;\n    remove.apply(tags[i], [tags, i]);\n  }\n}\n\n\n/**\n * Remove a child tag\n * @this Tag\n * @param   { Array } tags - tags collection\n * @param   { Number } i - index of the tag to remove\n */\nfunction remove(tags, i) {\n  tags.splice(i, 1);\n  this.unmount();\n  arrayishRemove(this.parent, this, this.__.tagName, true);\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @this Tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(i) {\n  var this$1 = this;\n\n  each(Object.keys(this.tags), function (tagName) {\n    moveChildTag.apply(this$1.tags[tagName], [tagName, i]);\n  });\n}\n\n/**\n * Move a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction move(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { moveVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Insert and mount a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction insert(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Append a new tag into the DOM\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction append(root, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.call(this, root); }\n  else\n    { root.appendChild(this.root); }\n}\n\n/**\n * Manage tags having the 'each'\n * @param   { HTMLElement } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n * @returns { Object } expression object for this each loop\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, LOOP_DIRECTIVE);\n\n  var mustReorder = typeof getAttr(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || remAttr(dom, LOOP_NO_REORDER_DIRECTIVE),\n    tagName = getTagName(dom),\n    impl = __TAG_IMPL[tagName],\n    parentNode = dom.parentNode,\n    placeholder = createDOMPlaceholder(),\n    child = getTag(dom),\n    ifExpr = getAttr(dom, CONDITIONAL_DIRECTIVE),\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isLoop = true,\n    isAnonymous = !__TAG_IMPL[tagName],\n    isVirtual = dom.tagName === 'VIRTUAL';\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr);\n  expr.isLoop = true;\n\n  if (ifExpr) { remAttr(dom, CONDITIONAL_DIRECTIVE); }\n\n  // insert a marked where the loop tags will be injected\n  parentNode.insertBefore(placeholder, dom);\n  parentNode.removeChild(dom);\n\n  expr.update = function updateEach() {\n    // get the new items collection\n    expr.value = tmpl(expr.val, parent);\n\n    var frag = createFrag(),\n      items = expr.value,\n      isObject$$1 = !isArray(items) && !isString(items),\n      root = placeholder.parentNode;\n\n    // object loop. any changes cause full redraw\n    if (isObject$$1) {\n      hasKeys = items || false;\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, items[key], key)\n        }) : [];\n    } else {\n      hasKeys = false;\n    }\n\n    if (ifExpr) {\n      items = items.filter(function(item, i) {\n        if (expr.key && !isObject$$1)\n          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\n        return !!tmpl(ifExpr, extend(Object.create(parent), item))\n      });\n    }\n\n    // loop all the new items\n    each(items, function(item, i) {\n      // reorder only if the items are objects\n      var\n        doReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,\n        oldPos = oldItems.indexOf(item),\n        isNew = oldPos === -1,\n        pos = !isNew && doReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos],\n        mustAppend = i >= oldItems.length,\n        mustCreate =  doReorder && isNew || !doReorder && !tag;\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\n      // new tag\n      if (mustCreate) {\n        tag = new Tag$1(impl, {\n          parent: parent,\n          isLoop: isLoop,\n          isAnonymous: isAnonymous,\n          tagName: tagName,\n          root: dom.cloneNode(isAnonymous),\n          item: item,\n          index: i,\n        }, dom.innerHTML);\n\n        // mount the tag\n        tag.mount();\n\n        if (mustAppend)\n          { append.apply(tag, [frag || root, isVirtual]); }\n        else\n          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n        if (!mustAppend) { oldItems.splice(i, 0, item); }\n        tags.splice(i, 0, tag);\n        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n      } else if (pos !== i && doReorder) {\n        // move\n        if (contains(items, oldItems[pos])) {\n          move.apply(tag, [root, tags[i], isVirtual]);\n          // move the old tag instance\n          tags.splice(i, 0, tags.splice(pos, 1)[0]);\n          // move the old item\n          oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n        }\n\n        // update the position attribute if it exists\n        if (expr.pos) { tag[expr.pos] = i; }\n\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag.__.item = item;\n      tag.__.index = i;\n      tag.__.parent = parent;\n\n      if (!mustCreate) { tag.update(item); }\n    });\n\n    // remove the redundant tags\n    unmountRedundant(items, tags);\n\n    // clone the items array\n    oldItems = items.slice();\n\n    root.insertBefore(frag, placeholder);\n  };\n\n  expr.unmount = function() {\n    each(tags, function(t) { t.unmount(); });\n  };\n\n  return expr\n}\n\n/**\n * Walk the tag DOM to detect the expressions to evaluate\n * @this Tag\n * @param   { HTMLElement } root - root tag where we will start digging the expressions\n * @param   { Array } expressions - empty array where the expressions will be added\n * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n * @returns { Object } an object containing the root noode and the dom tree\n */\nfunction parseExpressions(root, expressions, mustIncludeRoot) {\n  var this$1 = this;\n\n  var tree = {parent: {children: expressions}};\n\n  walkNodes(root, function (dom, ctx) {\n    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;\n    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\n    // text node\n    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\n    if (type !== 1) { return ctx } // not an element\n\n    var isVirtual = dom.tagName === 'VIRTUAL';\n\n    // loop. each does it's own thing (for now)\n    if (attr = getAttr(dom, LOOP_DIRECTIVE)) {\n      if(isVirtual) { setAttr(dom, 'loopVirtual', true); } // ignore here, handled in _each\n      parent.children.push(_each(dom, this$1, attr));\n      return false\n    }\n\n    // if-attrs become the new parent. Any following expressions (either on the current\n    // element, or below it) become children of this expression.\n    if (attr = getAttr(dom, CONDITIONAL_DIRECTIVE)) {\n      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n      return false\n    }\n\n    if (expr = getAttr(dom, IS_DIRECTIVE)) {\n      if (tmpl.hasExpr(expr)) {\n        parent.children.push({isRtag: true, expr: expr, dom: dom, attrs: [].slice.call(dom.attributes)});\n        return false\n      }\n    }\n\n    // if this is a tag, stop traversing here.\n    // we ignore the root, since parseExpressions is called while we're mounting that root\n    tagImpl = getTag(dom);\n    if(isVirtual) {\n      if(getAttr(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n      if(!tagImpl && !getAttr(dom, 'virtualized') && !getAttr(dom, 'loopVirtual'))  // ok to create virtual tag\n        { tagImpl = { tmpl: dom.outerHTML }; }\n    }\n\n    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n      if(isVirtual && !getAttr(dom, IS_DIRECTIVE)) { // handled in update\n        // can not remove attribute like directives\n        // so flag for removal after creation to prevent maximum stack error\n        setAttr(dom, 'virtualized', true);\n\n        var tag = new Tag$1({ tmpl: dom.outerHTML },\n          {root: dom, parent: this$1},\n          dom.innerHTML);\n        parent.children.push(tag); // no return, anonymous tag, keep parsing\n      } else {\n        var conf = {root: dom, parent: this$1, hasImpl: true};\n        parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n        return false\n      }\n    }\n\n    // attribute expressions\n    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {\n      if (!expr) { return }\n      parent.children.push(expr);\n    }]);\n\n    // whatever the parent is, all child elements get the same parent.\n    // If this element had an if-attr, that's the parent for all child elements\n    return {parent: parent}\n  }, tree);\n}\n\n/**\n * Calls `fn` for every attribute on an element. If that attr has an expression,\n * it is also passed to fn.\n * @this Tag\n * @param   { HTMLElement } dom - dom node to parse\n * @param   { Array } attrs - array of attributes\n * @param   { Function } fn - callback to exec on any iteration\n */\nfunction parseAttributes(dom, attrs, fn) {\n  var this$1 = this;\n\n  each(attrs, function (attr) {\n    var name = attr.name, bool = isBoolAttr(name), expr;\n\n    if (contains(REF_DIRECTIVES, name)) {\n      expr =  Object.create(RefExpr).init(dom, this$1, name, attr.value);\n    } else if (tmpl.hasExpr(attr.value)) {\n      expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n    }\n\n    fn(attr, expr);\n  });\n}\n\n/*\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\n\nvar reHasYield  = /<yield\\b/i;\nvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\nvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\nvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\nvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\nvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\nvar GENERIC = 'div';\n\n\n/*\n  Creates the root element for table or select child elements:\n  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n*/\nfunction specialTags(el, tmpl, tagName) {\n\n  var\n    select = tagName[0] === 'o',\n    parent = select ? 'select>' : 'table>';\n\n  // trim() is important here, this ensures we don't have artifacts,\n  // so we can check if we have only one element inside the parent\n  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n  parent = el.firstChild;\n\n  // returns the immediate parent if tr/th/td/col is the only element, if not\n  // returns the whole tree, as this can include additional elements\n  /* istanbul ignore next */\n  if (select) {\n    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n  } else {\n    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n    var tname = rootEls[tagName];\n    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n  }\n  return parent\n}\n\n/*\n  Replace the yield tag from any tag template with the innerHTML of the\n  original tag in the page\n*/\nfunction replaceYield(tmpl, html) {\n  // do nothing if no yield\n  if (!reHasYield.test(tmpl)) { return tmpl }\n\n  // be careful with #1343 - string on the source having `$1`\n  var src = {};\n\n  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n    src[ref] = src[ref] || text;   // preserve first definition\n    return ''\n  }).trim();\n\n  return tmpl\n    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n      return src[ref] || def || ''\n    })\n    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n      return html || def || ''\n    })\n}\n\n/**\n * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n *\n * @param   { String } tmpl  - The template coming from the custom tag definition\n * @param   { String } html - HTML content that comes from the DOM element where you\n *           will mount the tag, mostly the original tag in the page\n * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n */\nfunction mkdom(tmpl, html) {\n  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n    tagName = match && match[1].toLowerCase(),\n    el = mkEl(GENERIC);\n\n  // replace all the yield tags with the tag inner html\n  tmpl = replaceYield(tmpl, html);\n\n  /* istanbul ignore next */\n  if (tblTags.test(tagName))\n    { el = specialTags(el, tmpl, tagName); }\n  else\n    { setInnerHTML(el, tmpl); }\n\n  return el\n}\n\n/**\n * Another way to create a riot tag a bit more es6 friendly\n * @param { HTMLElement } el - tag DOM selector or DOM node/s\n * @param { Object } opts - tag logic\n * @returns { Tag } new riot tag instance\n */\nfunction Tag$2(el, opts) {\n  // get the tag properties from the class constructor\n  var ref = this;\n  var name = ref.name;\n  var tmpl = ref.tmpl;\n  var css = ref.css;\n  var attrs = ref.attrs;\n  var onCreate = ref.onCreate;\n  // register a new tag and cache the class prototype\n  if (!__TAG_IMPL[name]) {\n    tag$1(name, tmpl, css, attrs, onCreate);\n    // cache the class constructor\n    __TAG_IMPL[name].class = this.constructor;\n  }\n\n  // mount the tag using the class instance\n  mountTo(el, name, opts, this);\n  // inject the component css\n  if (css) { styleManager.inject(); }\n\n  return this\n}\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag$1(name, tmpl, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs;\n\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css;\n      css = '';\n    } else\n      { attrs = ''; }\n  }\n\n  if (css) {\n    if (isFunction(css))\n      { fn = css; }\n    else\n      { styleManager.add(css); }\n  }\n\n  name = name.toLowerCase();\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag2$1(name, tmpl, css, attrs, fn) {\n  if (css) { styleManager.add(css, name); }\n\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { * } selector - tag DOM selector or DOM node/s\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nfunction mount$1(selector, tagName, opts) {\n  var tags = [];\n\n  function pushTagsTo(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, IS_DIRECTIVE);\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName;\n        setAttr(root, IS_DIRECTIVE, tagName);\n      }\n\n      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\n      if (tag)\n        { tags.push(tag); }\n    } else if (root.length)\n      { each(root, pushTagsTo); } // assume nodeList\n  }\n\n  // inject styles into DOM\n  styleManager.inject();\n\n  if (isObject(tagName)) {\n    opts = tagName;\n    tagName = 0;\n  }\n\n  var elem;\n  var allTags;\n\n  // crawl the DOM to find the tag\n  if (isString(selector)) {\n    selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = selectTags() :\n      // or just the ones named like the selector\n      selector + selectTags(selector.split(/, */));\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    elem = selector ? $$(selector) : [];\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    { elem = selector; }\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectTags();\n    // if the root els it's just a single tag\n    if (elem.tagName)\n      { elem = $$(tagName, elem); }\n    else {\n      // select all the children for all the different root elements\n      var nodeList = [];\n\n      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n      elem = nodeList;\n    }\n    // get rid of the tagName\n    tagName = 0;\n  }\n\n  pushTagsTo(elem);\n\n  return tags\n}\n\n// Create a mixin that could be globally shared across all the tags\nvar mixins = {};\nvar globals = mixins[GLOBAL_MIXIN] = {};\nvar mixins_id = 0;\n\n/**\n * Create/Return a mixin by its name\n * @param   { String }  name - mixin name (global mixin if object)\n * @param   { Object }  mix - mixin logic\n * @param   { Boolean } g - is global?\n * @returns { Object }  the mixin logic\n */\nfunction mixin$1(name, mix, g) {\n  // Unnamed global\n  if (isObject(name)) {\n    mixin$1((\"__unnamed_\" + (mixins_id++)), name, true);\n    return\n  }\n\n  var store = g ? globals : mixins;\n\n  // Getter\n  if (!mix) {\n    if (isUndefined(store[name]))\n      { throw new Error('Unregistered mixin: ' + name) }\n\n    return store[name]\n  }\n\n  // Setter\n  store[name] = isFunction(mix) ?\n    extend(mix.prototype, store[name] || {}) && mix :\n    extend(store[name] || {}, mix);\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nfunction update$1() {\n  return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n}\n\nfunction unregister$1(name) {\n  delete __TAG_IMPL[name];\n}\n\nvar version$1 = 'v3.4.1';\n\n\nvar core = Object.freeze({\n\tTag: Tag$2,\n\ttag: tag$1,\n\ttag2: tag2$1,\n\tmount: mount$1,\n\tmixin: mixin$1,\n\tupdate: update$1,\n\tunregister: unregister$1,\n\tversion: version$1\n});\n\n// counter to give a unique id to all the Tag instances\nvar __uid = 0;\n\n/**\n * We need to update opts for this tag. That requires updating the expressions\n * in any attributes on the tag, and then copying the result onto opts.\n * @this Tag\n * @param   {Boolean} isLoop - is it a loop tag?\n * @param   { Tag }  parent - parent tag node\n * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n * @param   { Object }  opts - tag options\n * @param   { Array }  instAttrs - tag attributes array\n */\nfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n  // (and only this case) we don't need to do updateOpts, because the regular parse\n  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n  if (isLoop && isAnonymous) { return }\n\n  var ctx = !isAnonymous && isLoop ? this : parent || this;\n  each(instAttrs, function (attr) {\n    if (attr.expr) { updateAllExpressions.call(ctx, [attr.expr]); }\n    // normalize the attribute names\n    opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n  });\n}\n\n\n/**\n * Tag class\n * @constructor\n * @param { Object } impl - it contains the tag template, and logic\n * @param { Object } conf - tag options\n * @param { String } innerHTML - html that eventually we need to inject in the tag\n */\nfunction Tag$1(impl, conf, innerHTML) {\n  if ( impl === void 0 ) impl = {};\n  if ( conf === void 0 ) conf = {};\n\n  var opts = extend({}, conf.opts),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    isAnonymous = !!conf.isAnonymous,\n    skipAnonymous = settings$1.skipAnonymousTags && isAnonymous,\n    item = cleanUpData(conf.item),\n    index = conf.index, // available only for the looped nodes\n    instAttrs = [], // All attributes on the Tag when it's first parsed\n    implAttrs = [], // expressions on this type of Tag\n    expressions = [],\n    root = conf.root,\n    tagName = conf.tagName || getTagName(root),\n    isVirtual = tagName === 'virtual',\n    propsInSyncWithParent = [],\n    dom;\n\n  // make this tag observable\n  if (!skipAnonymous) { observable$1(this); }\n  // only call unmount if we have a valid __TAG_IMPL (has name property)\n  if (impl.name && root._tag) { root._tag.unmount(true); }\n\n  // not yet mounted\n  this.isMounted = false;\n\n  defineProperty(this, '__', {\n    isAnonymous: isAnonymous,\n    instAttrs: instAttrs,\n    innerHTML: innerHTML,\n    tagName: tagName,\n    index: index,\n    isLoop: isLoop,\n    // tags having event listeners\n    // it would be better to use weak maps here but we can not introduce breaking changes now\n    listeners: [],\n    // these vars will be needed only for the virtual tags\n    virts: [],\n    tail: null,\n    head: null,\n    parent: null,\n    item: null\n  });\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n  defineProperty(this, 'root', root);\n  extend(this, { opts: opts }, item);\n  // protect the \"tags\" and \"refs\" property from being overridden\n  defineProperty(this, 'parent', parent || null);\n  defineProperty(this, 'tags', {});\n  defineProperty(this, 'refs', {});\n\n  dom = isLoop && isAnonymous ? root : mkdom(impl.tmpl, innerHTML, isLoop);\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'update', function tagUpdate(data) {\n    var nextOpts = {},\n      canTrigger = this.isMounted && !skipAnonymous;\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data);\n    extend(this, data);\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, nextOpts, instAttrs]);\n\n    if (canTrigger && this.isMounted && isFunction(this.shouldUpdate) && !this.shouldUpdate(data, nextOpts)) {\n      return this\n    }\n\n    // inherit properties from the parent, but only for isAnonymous tags\n    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n    extend(opts, nextOpts);\n    if (canTrigger) { this.trigger('update', data); }\n    updateAllExpressions.call(this, expressions);\n    if (canTrigger) { this.trigger('updated'); }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mixin', function tagMixin() {\n    var this$1 = this;\n\n    each(arguments, function (mix) {\n      var instance, obj;\n      var props = [];\n\n      // properties blacklisted and will not be bound to the tag instance\n      var propsBlacklist = ['init', '__proto__'];\n\n      mix = isString(mix) ? mixin$1(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else { instance = mix; }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to this\n        // allow mixins to override other properties/parent mixins\n        if (!contains(propsBlacklist, key)) {\n          // check for getters/setters\n          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(this$1, key, descriptor);\n          } else {\n            this$1[key] = isFunction(instance[key]) ?\n              instance[key].bind(this$1) :\n              instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init)\n        { instance.init.bind(this$1)(); }\n    });\n    return this\n  }.bind(this));\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mount', function tagMount() {\n    var this$1 = this;\n\n    root._tag = this; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n      attr.expr = expr;\n      instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    implAttrs = [];\n    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n      if (expr) { expressions.push(expr); }\n      else { setAttr(root, attr.name, attr.value); }\n    }]);\n\n    // initialiation\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin$1(GLOBAL_MIXIN);\n\n    if (globalMixin && !skipAnonymous) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          this$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (impl.fn) { impl.fn.call(this, opts); }\n\n    if (!skipAnonymous) { this.trigger('before-mount'); }\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions.apply(this, [dom, expressions, isAnonymous]);\n\n    this.update(item);\n\n    if (!isAnonymous) {\n      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n    }\n\n    defineProperty(this, 'root', root);\n    defineProperty(this, 'isMounted', true);\n\n    if (skipAnonymous) { return }\n\n    // if it's not a child tag we can trigger its mount event\n    if (!this.parent) {\n      this.trigger('mount');\n    }\n    // otherwise we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n    else {\n      var p = getImmediateCustomParentTag(this.parent);\n      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n        this$1.trigger('mount');\n      });\n    }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n    var this$1 = this;\n\n    var el = this.root,\n      p = el.parentNode,\n      ptag,\n      tagIndex = __TAGS_CACHE.indexOf(this);\n\n    if (!skipAnonymous) { this.trigger('before-unmount'); }\n\n    // clear all attributes coming from the mounted tag\n    walkAttrs(impl.attrs, function (name) {\n      if (startsWith(name, ATTRS_PREFIX))\n        { name = name.slice(ATTRS_PREFIX.length); }\n      remAttr(root, name);\n    });\n\n    // remove all the event listeners\n    this.__.listeners.forEach(function (dom) {\n      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n      });\n    });\n\n    // remove this tag instance from the global virtualDom variable\n    if (tagIndex !== -1)\n      { __TAGS_CACHE.splice(tagIndex, 1); }\n\n    if (p || isVirtual) {\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent);\n\n        if (isVirtual) {\n          Object.keys(this.tags).forEach(function (tagName) {\n            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n          });\n        } else {\n          arrayishRemove(ptag.tags, tagName, this);\n          if(parent !== ptag) // remove from _parent too\n            { arrayishRemove(parent.tags, tagName, this); }\n        }\n      } else {\n        // remove the tag contents\n        setInnerHTML(el, '');\n      }\n\n      if (p && !mustKeepRoot) { p.removeChild(el); }\n\n      // the data-is attributes isn't needed anymore, remove it\n      remAttr(el, IS_DIRECTIVE);\n    }\n\n    if (this.__.virts) {\n      each(this.__.virts, function (v) {\n        if (v.parentNode) { v.parentNode.removeChild(v); }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n    // custom internal unmount function to avoid relying on the observable\n    if (this.__.onUnmount) { this.__.onUnmount(); }\n\n    if (!skipAnonymous) {\n      this.trigger('unmount');\n      this.off('*');\n    }\n\n    defineProperty(this, 'isMounted', false);\n\n    delete this.root._tag;\n\n    return this\n\n  }.bind(this));\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __TAG_IMPL[getAttr(dom, IS_DIRECTIVE) ||\n    getAttr(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n}\n\n/**\n * Inherit properties from a target tag instance\n * @this Tag\n * @param   { Tag } target - tag where we will inherit properties\n * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n */\nfunction inheritFrom(target, propsInSyncWithParent) {\n  var this$1 = this;\n\n  each(Object.keys(target), function (k) {\n    // some properties must be always in sync with the parent tag\n    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\n    if (isUndefined(this$1[k]) || mustSync) {\n      // track the property to keep in sync\n      // so we can keep it updated\n      if (!mustSync) { propsInSyncWithParent.push(k); }\n      this$1[k] = target[k];\n    }\n  });\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @this Tag\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tagName, newPos) {\n  var parent = this.parent,\n    tags;\n  // no parent no move\n  if (!parent) { return }\n\n  tags = parent.tags[tagName];\n\n  if (isArray(tags))\n    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n  else { arrayishAdd(parent.tags, tagName, this); }\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag$1(child, opts, innerHTML),\n    tagName = opts.tagName || getTagName(opts.root, true),\n    ptag = getImmediateCustomParentTag(parent);\n  // fix for the parent attribute in the looped elements\n  defineProperty(tag, 'parent', ptag);\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag.__.parent = parent;\n\n  // add this tag to the custom parent tag\n  arrayishAdd(ptag.tags, tagName, tag);\n\n  // and also to the real parent tag\n  if (ptag !== parent)\n    { arrayishAdd(parent.tags, tagName, tag); }\n\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = '';\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag;\n  while (ptag.__.isAnonymous) {\n    if (!ptag.parent) { break }\n    ptag = ptag.parent;\n  }\n  return ptag\n}\n\n/**\n * Trigger the unmount method on all the expressions\n * @param   { Array } expressions - DOM expressions\n */\nfunction unmountAll(expressions) {\n  each(expressions, function(expr) {\n    if (expr instanceof Tag$1) { expr.unmount(true); }\n    else if (expr.tagName) { expr.tag.unmount(true); }\n    else if (expr.unmount) { expr.unmount(); }\n  });\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom, skipDataIs) {\n  var child = getTag(dom),\n    namedTag = !skipDataIs && getAttr(dom, IS_DIRECTIVE);\n  return namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n}\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag$1) && !(data && isFunction(data.trigger)))\n    { return data }\n\n  var o = {};\n  for (var key in data) {\n    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }\n  }\n  return o\n}\n\n/**\n * Set the property of an object for a given key. If something already\n * exists there, then it becomes an array containing both the old and new value.\n * @param { Object } obj - object on which to set the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be set\n * @param { Boolean } ensureArray - ensure that the property remains an array\n * @param { Number } index - add the new item in a certain array position\n */\nfunction arrayishAdd(obj, key, value, ensureArray, index) {\n  var dest = obj[key];\n  var isArr = isArray(dest);\n  var hasIndex = !isUndefined(index);\n\n  if (dest && dest === value) { return }\n\n  // if the key was never set, set it once\n  if (!dest && ensureArray) { obj[key] = [value]; }\n  else if (!dest) { obj[key] = value; }\n  // if it was an array and not yet set\n  else {\n    if (isArr) {\n      var oldIndex = dest.indexOf(value);\n      // this item never changed its position\n      if (oldIndex === index) { return }\n      // remove the item from its old position\n      if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n      // move or add the item\n      if (hasIndex) {\n        dest.splice(index, 0, value);\n      } else {\n        dest.push(value);\n      }\n    } else { obj[key] = [dest, value]; }\n  }\n}\n\n/**\n * Removes an item from an object at a given key. If the key points to an array,\n * then the item is just removed from the array.\n * @param { Object } obj - object on which to remove the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be removed\n * @param { Boolean } ensureArray - ensure that the property remains an array\n*/\nfunction arrayishRemove(obj, key, value, ensureArray) {\n  if (isArray(obj[key])) {\n    var index = obj[key].indexOf(value);\n    if (index !== -1) { obj[key].splice(index, 1); }\n    if (!obj[key].length) { delete obj[key]; }\n    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n  } else\n    { delete obj[key]; } // otherwise just delete the key\n}\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts, ctx) {\n  var impl = __TAG_IMPL[tagName],\n    implClass = __TAG_IMPL[tagName].class,\n    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\n  // clear the inner html\n  root.innerHTML = '';\n\n  var conf = extend({ root: root, opts: opts }, { parent: opts ? opts.parent : null });\n\n  if (impl && root) { Tag$1.apply(tag, [impl, conf, innerHTML]); }\n\n  if (tag && tag.mount) {\n    tag.mount(true);\n    // add this tag to the virtualDom variable\n    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n  }\n\n  return tag\n}\n\n/**\n * makes a tag virtual and replaces a reference in the dom\n * @this Tag\n * @param { tag } the tag to make virtual\n * @param { ref } the dom reference location\n */\nfunction makeReplaceVirtual(tag, ref) {\n  var frag = createFrag();\n  makeVirtual.call(tag, frag);\n  ref.parentNode.replaceChild(frag, ref);\n}\n\n/**\n * Adds the elements for a virtual tag\n * @this Tag\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction makeVirtual(src, target) {\n  var this$1 = this;\n\n  var head = createDOMPlaceholder(),\n    tail = createDOMPlaceholder(),\n    frag = createFrag(),\n    sib, el;\n\n  this.root.insertBefore(head, this.root.firstChild);\n  this.root.appendChild(tail);\n\n  this.__.head = el = head;\n  this.__.tail = tail;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    this$1.__.virts.push(el); // hold for unmounting\n    el = sib;\n  }\n\n  if (target)\n    { src.insertBefore(frag, target.__.head); }\n  else\n    { src.appendChild(frag); }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @this Tag\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n */\nfunction moveVirtual(src, target) {\n  var this$1 = this;\n\n  var el = this.__.head,\n    frag = createFrag(),\n    sib;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    el = sib;\n    if (el === this$1.__.tail) {\n      frag.appendChild(el);\n      src.insertBefore(frag, target.__.head);\n      break\n    }\n  }\n}\n\n/**\n * Get selectors for tags\n * @param   { Array } tags - tag names to select\n * @returns { String } selector\n */\nfunction selectTags(tags) {\n  // select all tags\n  if (!tags) {\n    var keys = Object.keys(__TAG_IMPL);\n    return keys + selectTags(keys)\n  }\n\n  return tags\n    .filter(function (t) { return !/[^-\\w]/.test(t); })\n    .reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n    }, '')\n}\n\n\nvar tags = Object.freeze({\n\tgetTag: getTag,\n\tinheritFrom: inheritFrom,\n\tmoveChildTag: moveChildTag,\n\tinitChildTag: initChildTag,\n\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\tunmountAll: unmountAll,\n\tgetTagName: getTagName,\n\tcleanUpData: cleanUpData,\n\tarrayishAdd: arrayishAdd,\n\tarrayishRemove: arrayishRemove,\n\tmountTo: mountTo,\n\tmakeReplaceVirtual: makeReplaceVirtual,\n\tmakeVirtual: makeVirtual,\n\tmoveVirtual: moveVirtual,\n\tselectTags: selectTags\n});\n\n/**\n * Riot public api\n */\nvar settings = settings$1;\nvar util = {\n  tmpl: tmpl,\n  brackets: brackets,\n  styleManager: styleManager,\n  vdom: __TAGS_CACHE,\n  styleNode: styleManager.styleNode,\n  // export the riot internal utils as well\n  dom: dom,\n  check: check,\n  misc: misc,\n  tags: tags\n};\n\n// export the core props/methods\nvar Tag$$1 = Tag$2;\nvar tag$$1 = tag$1;\nvar tag2$$1 = tag2$1;\nvar mount$$1 = mount$1;\nvar mixin$$1 = mixin$1;\nvar update$$1 = update$1;\nvar unregister$$1 = unregister$1;\nvar version$$1 = version$1;\nvar observable = observable$1;\n\nvar riot$1 = extend({}, core, {\n  observable: observable$1,\n  settings: settings,\n  util: util,\n});\n\nexports.settings = settings;\nexports.util = util;\nexports.Tag = Tag$$1;\nexports.tag = tag$$1;\nexports.tag2 = tag2$$1;\nexports.mount = mount$$1;\nexports.mixin = mixin$$1;\nexports.update = update$$1;\nexports.unregister = unregister$$1;\nexports.version = version$$1;\nexports.observable = observable;\nexports['default'] = riot$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n// WEBPACK FOOTER //\n// ../~/riot/riot.js","import riot from 'riot'\nimport '../tags/app.tag'\n\nriot.mount('app');\n\n\n// WEBPACK FOOTER //\n// ./scripts/app.js","var map = {\n\t\"./index.html\": 5\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 3;\n\n\n//////////////////\n// WEBPACK FOOTER\n// . \\.(html)\n// module id = 3\n// module chunks = 0","import './app.js'\n\nrequire.context('../', true, /\\.(html)/);\nrequire('../styles/main.styl');\n\n\n\n// WEBPACK FOOTER //\n// ./scripts/main.js","module.exports = __webpack_public_path__ + \"index.html\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.html\n// module id = 5\n// module chunks = 0","\n    var riot = require('riot')\n    riot.tag2('app', '<h1>asdASDA</h1> <p>ASd</p>', '', '', function(opts) {\n        console.log('I am tag!');\n});\n    \n  \n\n\n//////////////////\n// WEBPACK FOOTER\n// ./tags/app.tag\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}